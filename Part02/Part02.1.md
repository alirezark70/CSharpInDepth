
این بخش از کتاب تمام ویژگی‌های معرفی شده بین C# 2 (عرضه شده با ویژوال استودیو 2005 - Visual Studio 2005) و C# 5 (عرضه شده با ویژوال استودیو 2012 - Visual Studio 2012) را پوشش می‌دهد. این همان مجموعه‌ای از ویژگی‌هاست که کل ویرایش سوم این کتاب را به خود اختصاص داده بود. اکنون بسیاری از آن به نظر تاریخ باستان می‌آید؛ برای مثال، ما به سادگی پذیرفته‌ایم که C# شامل جنریک‌ها (generics) است.

<div dir="rtl" align="right">


این دوره برای C# فوق‌العاده پربار بود. برخی از ویژگی‌هایی که در این بخش پوشش خواهم داد عبارتند از:
* جنریک‌ها (generics)
* انواع مقادیر nullable (nullable value types)
* متدهای ناشناس (anonymous methods)
* تبدیل گروه متدها (method group conversions)
* تکرارکننده‌ها (iterators)
* انواع جزئی (partial types)
* کلاس‌های استاتیک (static classes)
* ویژگی‌های پیاده‌سازی شده خودکار (automatically implemented properties)
* متغیرهای محلی با نوع ضمنی (implicitly typed local variables)
* آرایه‌های با نوع ضمنی (implicitly typed arrays)
* مقداردهنده‌های شیء (object initializers)
* مقداردهنده‌های مجموعه (collection initializers)
* انواع ناشناس (anonymous types)
* عبارات لامبدا (lambda expressions)
* متدهای توسعه (extension methods)
* عبارات کوئری (query expressions)
* تایپ پویا (dynamic typing)
* پارامترهای اختیاری (optional parameters)
* آرگومان‌های نام‌گذاری شده (named arguments)
* بهبودهای COM (COM improvements)
* کوواریانس و کنتراواریانس جنریک (generic covariance and contravariance)

 async/await

* ویژگی‌های اطلاعات فراخواننده (caller information attributes)

اوه! انتظار دارم بیشتر شما حداقل تا حدودی با اکثر این ویژگی‌ها آشنا باشید، بنابراین در این بخش با سرعت بیشتری پیش می‌روم. به همین ترتیب، به خاطر اختصار معقول، به جزئیات ویرایش سوم نپرداخته‌ام.

هدف این است که طیف وسیعی از نیازهای خواننده را پوشش دهم:
* مقدمه‌ای بر ویژگی‌هایی که ممکن است در طول مسیر از دست داده باشید
* یادآوری ویژگی‌هایی که زمانی می‌دانستید اما فراموش کرده‌اید
* توضیحی در مورد دلایل پشت ویژگی‌ها: چرا معرفی شدند و چرا به این شکل طراحی شدند
* مرجع سریع در صورتی که می‌دانید چه کاری می‌خواهید انجام دهید اما برخی از سینتکس‌ها را فراموش کرده‌اید

---

</div>

### فصل 20

اگر جزئیات بیشتری می‌خواهید، لطفاً به ویرایش سوم مراجعه کنید. به عنوان یادآوری، خرید ویرایش چهارم به شما یک نسخه کتاب الکترونیکی از ویرایش سوم را می‌دهد.

یک استثنا در این قانون پوشش مختصر وجود دارد: من پوشش async/await را به طور کامل بازنویسی کرده‌ام که بزرگترین ویژگی در C# 5 است.

---

### فصل 5

فصل 5 آنچه را که برای استفاده از async/await باید بدانید را پوشش می‌دهد و فصل 6 به چگونگی پیاده‌سازی آن در پشت صحنه می‌پردازد.

اگر با async/await ناآشنا هستید، تقریباً مطمئناً می‌خواهید صبر کنید تا کمی از آن استفاده کنید قبل از اینکه فصل 6 را بخوانید، و حتی در آن صورت، نباید انتظار یک مطالعه ساده را داشته باشید. من سعی کرده‌ام همه چیز را تا حد امکان قابل دسترس توضیح دهم، اما این موضوع ذاتاً پیچیده است. با این حال، شما را تشویق می‌کنم که تلاش کنید؛ درک async/await در سطح عمیق می‌تواند به افزایش اعتماد به نفس شما هنگام استفاده از این ویژگی کمک کند، حتی اگر هرگز نیازی به بررسی IL تولید شده توسط کامپایلر برای کد خود نداشته باشید.

خبر خوب این است که پس از فصل 6، با فصل 7 کمی آسودگی خاطر خواهید یافت. این کوتاه‌ترین فصل کتاب و فرصتی برای ریکاوری قبل از بررسی C# 6 است. با تمام مقدمات خارج از این بحث.



<div dir="rtl" align="right">
این فصل به موارد زیر می‌پردازد:
* استفاده از انواع و متدهای جنریک (generic) برای کد انعطاف‌پذیر و ایمن
* بیان عدم وجود اطلاعات با انواع مقادیر Nullable (nullable value types)
* ساخت آسان‌تر دلیگیت‌ها (delegates)
* پیاده‌سازی تکرارکننده‌ها (iterators) بدون نوشتن کد اضافی

برای من، پاسخ این سوال ساده است: C# 1 در آن زمان برای بسیاری از توسعه‌دهندگان، زبان پربارتری نسبت به جاوا (Java) بود.
</div>

<div dir="rtl" align="right">
### 22 فصل 2 C# 2
</div>

<div dir="rtl" align="right">
اهمیت انتشار آن را در آن زمان دست کم نگیرید. همچنین دردناک بود: ارتقا از C# 1 و NET 1.x. به C# 2 و NET 2.0. زمان زیادی طول کشید تا در صنعت فراگیر شود. تکامل‌های بعدی بسیار سریع‌تر بوده‌اند. اولین ویژگی از C# 2 که تقریباً همه توسعه‌دهندگان آن را مهم‌ترین می‌دانند: جنریک‌ها (generics) هستند.
</div>

<div dir="rtl" align="right">
#### 2.1 جنریک‌ها (Generics)
</div>

<div dir="rtl" align="right">
جنریک‌ها به شما امکان می‌دهند کدی با هدف عمومی بنویسید که در زمان کامپایل (compile time) از نظر نوع ایمن (type safe) باشد و از یک نوع در چندین مکان استفاده کنید بدون اینکه از قبل بدانید آن نوع چیست. وقتی جنریک‌ها برای اولین بار معرفی شدند، کاربرد اصلی آن‌ها برای کالکشن‌ها (collections) بود، اما در کد مدرن C#، آن‌ها همه جا پیدا می‌شوند. آن‌ها احتمالاً بیشترین استفاده را برای موارد زیر دارند:
* کالکشن‌ها (آن‌ها در کالکشن‌ها به همان اندازه همیشه مفید هستند)
* دلیگیت‌ها (delegates)، به خصوص در LINQ
* کد ناهمزمان (asynchronous code)، که در آن `Task<T>` قولی برای یک مقدار `T` در آینده است.
* انواع مقادیر nullable (nullable value types)، که در بخش 2.2 بیشتر در مورد آن‌ها صحبت خواهم کرد.
</div>

<div dir="rtl" align="right">
این به هیچ وجه محدودیت کاربرد آن‌ها نیست، اما حتی همین چهار مورد به این معنی است که برنامه‌نویسان C# روزانه از جنریک‌ها استفاده می‌کنند. کالکشن‌ها ساده‌ترین راه برای توضیح مزایای جنریک‌ها را ارائه می‌دهند، زیرا می‌توانید به کالکشن‌ها در NET 1. نگاه کنید و آن‌ها را با کالکشن‌های جنریک در NET 2. مقایسه کنید.
</div>

<div dir="rtl" align="right">
##### 2.1.1 معرفی با مثال: کالکشن‌ها قبل از جنریک‌ها
</div>

<div dir="rtl" align="right">
NET 1. سه نوع کلی کالکشن داشت:
* آرایه‌ها (Arrays)—این‌ها دارای پشتیبانی مستقیم زبان و زمان اجرا (runtime) هستند. اندازه آن‌ها در زمان مقداردهی اولیه (initialization) ثابت است.
* کالکشن‌های مبتنی بر شیء (Object-based collections)—مقادیر (و کلیدها در صورت لزوم) در API با استفاده از `System.Object` توصیف می‌شوند. این‌ها هیچ پشتیبانی زبانی یا زمان اجرایی خاص کالکشن ندارند، اگرچه ویژگی‌های زبانی مانند ایندکسرها (indexers) و دستورات foreach می‌توانند با آن‌ها استفاده شوند. `ArrayList` و `Hashtable` رایج‌ترین مثال‌ها هستند.
* کالکشن‌های تخصصی (Specialized collections)—مقادیر در API با یک نوع خاص توصیف می‌شوند، و کالکشن فقط برای آن نوع قابل استفاده است. برای مثال، `StringCollection` یک کالکشن از رشته‌ها است؛ API آن شبیه `ArrayList` است اما به جای `Object` از `String` برای هر چیزی که به یک مقدار اشاره دارد استفاده می‌کند.
</div>

<div dir="rtl" align="right">
آرایه‌ها و کالکشن‌های تخصصی به صورت استاتیک (statically typed) هستند، که منظور من این است که API از قرار دادن نوع اشتباهی از مقدار در یک کالکشن جلوگیری می‌کند، و وقتی مقداری را از کالکشن واکشی می‌کنید، نیازی به تبدیل (cast) نتیجه به نوعی که انتظار دارید نیست.
</div>


<div dir="rtl" align="right">
نکته: آرایه‌های نوع مرجع (Reference type arrays) فقط در ذخیره مقادیر تا حد زیادی ایمن هستند به دلیل کوواریانس آرایه (array covariance). من کوواریانس آرایه را یک اشتباه طراحی اولیه می‌دانم که فراتر از محدوده این کتاب است. اریک لیپرت (Eric Lippert) در مورد این موضوع در [http://mng.bz/gYPv](http://mng.bz/gYPv) به عنوان بخشی از سری پست‌های وبلاگ خود در مورد کوواریانس (covariance) و کنتراواریانس (contravariance) نوشت.
</div>

<div dir="rtl" align="right">
### جنریک‌ها 23
</div>

<div dir="rtl" align="right">
بیایید این را مشخص کنیم: فرض کنید می‌خواهید مجموعه‌ای از رشته‌ها را در یک متد (`GenerateNames`) ایجاد کنید و آن رشته‌ها را در متد دیگری (`PrintNames`) چاپ کنید. شما سه گزینه را برای نگهداری مجموعه نام‌ها بررسی خواهید کرد - آرایه‌ها (arrays)، `ArrayList` و `StringCollection` - و مزایا و معایب هر کدام را بررسی خواهید کرد. کد در هر مورد مشابه به نظر می‌رسد (به خصوص برای `PrintNames`)، اما با من همراه باشید. با آرایه‌ها شروع می‌کنیم.
</div>

```csharp
static string[] GenerateNames()
{
    string[] names = new string[4];
    names[0] = "Gamma";
    names[1] = "Vlissides";
    names[2] = "Johnson";
    names[3] = "Helm";
    return names;
}

static void PrintNames(string[] names)
{
    foreach (string name in names)
    {
        Console.WriteLine(name);
    }
}
```

<div dir="rtl" align="right">
من در اینجا از مقداردهنده آرایه (array initializer) استفاده نکرده‌ام، زیرا می‌خواهم وضعیتی را تقلید کنم که نام‌ها یکی یکی کشف می‌شوند، مانند زمانی که آن‌ها را از یک فایل می‌خوانیم. با این حال، توجه داشته باشید که باید آرایه را در ابتدا به اندازه صحیح تخصیص دهید. اگر واقعاً از یک فایل می‌خواندید، یا باید قبل از شروع کار متوجه می‌شدید چند نام وجود دارد، یا باید کد پیچیده‌تری می‌نوشتید. به عنوان مثال، می‌توانستید در ابتدا یک آرایه تخصیص دهید، اگر آرایه اول پر شد، محتویات را به یک آرایه بزرگتر کپی کنید و غیره. سپس باید در نظر می‌گرفتید که اگر در نهایت آرایه‌ای بزرگتر از تعداد دقیق نام‌ها داشتید، یک آرایه نهایی با اندازه صحیح ایجاد کنید. کدی که تاکنون اندازه مجموعه ما را ردیابی می‌کند، یک آرایه را دوباره تخصیص می‌دهد و غیره تکراری است و می‌تواند در یک نوع کپسوله شود. اتفاقاً، `ArrayList` دقیقاً همین کار را می‌کند.
</div>

```csharp
static ArrayList GenerateNames()
{
    ArrayList names = new ArrayList();
    names.Add("Gamma");
    names.Add("Vlissides");
    names.Add("Johnson");
    names.Add("Helm");
    return names;
}
```

<div dir="rtl" align="right">
لیست 2.1 ایجاد و چاپ نام‌ها با استفاده از آرایه‌ها
لیست 2.2 ایجاد و چاپ نام‌ها با استفاده از ArrayList
اندازه آرایه باید در زمان ایجاد مشخص باشد.
</div>

<div dir="rtl" align="right">
### 24 فصل 2 C# 2
</div>

```csharp
static void PrintNames(ArrayList names)
{
    foreach (string name in names)
    {
        Console.WriteLine(name);
    }
}
```

<div dir="rtl" align="right">
این از نظر متد `GenerateNames` ما تمیزتر است: لازم نیست قبل از شروع اضافه کردن به کالکشن بدانید چند نام دارید. اما به همین ترتیب، هیچ چیز مانع از اضافه کردن یک غیر رشته (nonstring) به کالکشن نمی‌شود؛ نوع پارامتر `ArrayList.Add` فقط `Object` است.
</div>

<div dir="rtl" align="right">
علاوه بر این، اگرچه متد `PrintNames` از نظر نوع ایمن به نظر می‌رسد، اما اینطور نیست. کالکشن می‌تواند هر نوع ارجاع شیء (object reference) را شامل شود. چه انتظاری دارید اگر یک نوع کاملاً متفاوت (مثلاً یک `WebRequest`) را به کالکشن اضافه کنید و سپس سعی کنید آن را چاپ کنید؟ حلقه `foreach` یک تبدیل ضمنی (implicit cast) را از `object` به `string` پنهان می‌کند، به دلیل نوع متغیر `name`. آن تبدیل می‌تواند به طور معمول با یک `InvalidCastException` شکست بخورد. بنابراین، شما یک مشکل را حل کرده‌اید اما مشکل دیگری ایجاد کرده‌اید. آیا چیزی هست که هر دو اینها را حل کند؟
</div>


```csharp
static StringCollection GenerateNames()
{
    StringCollection names = new StringCollection();
    names.Add("Gamma");
    names.Add("Vlissides");
    names.Add("Johnson");
    names.Add("Helm");
    return names;
}

static void PrintNames(StringCollection names)
{
    foreach (string name in names)
    {
        Console.WriteLine(name);
    }
}
```

<div dir="rtl" align="right">
لیست 2.3 با لیست 2.2 یکسان است به جز جایگزینی `ArrayList` با `StringCollection` در همه جا. این تمام هدف `StringCollection` است: باید مانند یک مجموعه عمومی دلپذیر باشد اما تخصصی شده برای مدیریت فقط رشته‌ها. نوع پارامتر `StringCollection.Add` از نوع `String` است، بنابراین شما نمی‌توانید یک `WebRequest` را از طریق یک باگ عجیب در کد ما به آن اضافه کنید. نتیجه این است که وقتی نام‌ها را چاپ می‌کنید، می‌توانید مطمئن باشید که حلقه `foreach` با هیچ ارجاع غیر رشته‌ای مواجه نخواهد شد. (البته هنوز هم می‌توانید یک ارجاع `null` را مشاهده کنید.)
</div>

<div dir="rtl" align="right">
این عالی است اگر همیشه فقط به رشته‌ها نیاز دارید. اما اگر به مجموعه‌ای از نوع دیگری نیاز دارید، باید یا امیدوار باشید که از قبل یک نوع مجموعه مناسب در چارچوب وجود دارد یا خودتان یکی بنویسید. این یک کار بسیار رایج بود که یک کلاس انتزاعی `System.Collections.CollectionBase` وجود دارد تا کار را تا حدودی کمتر تکراری کند. همچنین مولدهای کد (code generators) برای جلوگیری از نوشتن همه چیز با دست وجود دارد.
</div>

<div dir="rtl" align="right">
این هر دو مشکل راه حل قبلی را حل می‌کند، اما هزینه داشتن همه این انواع اضافی بیش از حد بالا است. هزینه نگهداری برای به‌روز نگه داشتن آن‌ها با تغییر مولد کد وجود دارد. هزینه‌های کارایی از نظر زمان کامپایل، اندازه اسمبلی، زمان JITting و نگهداری کد در حافظه وجود دارد. از همه مهمتر، هزینه انسانی در ردیابی همه کلاس‌های مجموعه موجود وجود دارد.
</div>

<div dir="rtl" align="right">
حتی اگر این هزینه‌ها بیش از حد بالا نبود، شما توانایی نوشتن متدی را از دست می‌دادید که بتواند روی هر نوع مجموعه به روشی استاتیک (statically typed) کار کند، به طور بالقوه از نوع عنصر مجموعه در یک پارامتر دیگر یا در نوع بازگشتی (return type) استفاده کند. به عنوان مثال، فرض کنید می‌خواهید متدی بنویسید تا N عنصر اول یک مجموعه را به یک مجموعه جدید کپی کند و سپس آن را برگرداند. می‌توانید متدی بنویسید که یک `ArrayList` برگرداند، اما این باعث از دست رفتن خوبی تایپ استاتیک می‌شود. اگر یک `StringCollection` را ارسال کنید، یک `StringCollection` را برمی‌گردانید. جنبه رشته بخشی از ورودی متد است که سپس باید به خروجی نیز منتقل شود. شما در زمان استفاده از C# 1 راهی برای بیان این موضوع در زبان نداشتید. وارد جنریک‌ها (generics) شوید.
</div>


<div dir="rtl" align="right">
#### 2.1.2 جنریک‌ها گره‌گشا می‌شوند
</div>

<div dir="rtl" align="right">
بیایید مستقیم برویم سراغ راه‌حل کد `GenerateNames`/`PrintNames` و از نوع جنریک `List<T>` استفاده کنیم. `List<T>` یک کالکشن است که در آن `T` نوع عنصر کالکشن است – در مورد ما، `string`. شما می‌توانید `StringCollection` را در همه جا با `List<string>` جایگزین کنید.
</div>

```csharp
static List<string> GenerateNames()
{
    List<string> names = new List<string>();
    names.Add("Gamma");
    names.Add("Vlissides");
    names.Add("Johnson");
    names.Add("Helm");
    return names;
}

static void PrintNames(List<string> names)
{
    foreach (string name in names)
    {
        Console.WriteLine(name);
    }
}
```

<div dir="rtl" align="right">
لیست 2.4 تولید و چاپ نام‌ها با `List<T>`

`List<T>` تمام مشکلاتی را که قبلاً در مورد آن‌ها صحبت کردیم حل می‌کند:
* شما نیازی ندارید که از قبل اندازه کالکشن را بدانید، برخلاف آرایه‌ها (arrays).
* API (رابط برنامه‌نویسی کاربردی) نمایش داده شده از `T` در هر جایی که نیاز به ارجاع به نوع عنصر دارد استفاده می‌کند، بنابراین می‌دانید که یک `List<string>` فقط شامل ارجاعات رشته (string references) خواهد بود. اگر سعی کنید چیز دیگری اضافه کنید، برخلاف `ArrayList`، یک خطای زمان کامپایل (compile-time error) دریافت خواهید کرد.
* می‌توانید از آن با هر نوع عنصری بدون نگرانی در مورد تولید کد و مدیریت نتیجه استفاده کنید، برخلاف `StringCollection` و انواع مشابه.
</div>

<div dir="rtl" align="right">
جنریک‌ها (Generics) همچنین مشکل بیان نوع یک عنصر به عنوان ورودی یک متد (method) را حل می‌کنند. برای بررسی عمیق‌تر این جنبه، به اصطلاحات بیشتری نیاز خواهید داشت.
</div>

<div dir="rtl" align="right">
#### پارامترهای نوع (TYPE PARAMETERS) و آرگومان‌های نوع (TYPE ARGUMENTS)
</div>

<div dir="rtl" align="right">
اصطلاحات پارامتر (parameter) و آرگومان (argument) قبل از جنریک‌ها در C# وجود داشته و دهه‌ها در زبان‌های دیگر استفاده شده‌اند. یک متد ورودی‌های خود را به عنوان پارامتر اعلام می‌کند، و آن‌ها توسط کد فراخواننده (calling code) در قالب آرگومان‌ها ارائه می‌شوند. شکل 2.1 نشان می‌دهد که این دو چگونه با یکدیگر ارتباط دارند.
</div>

<div dir="rtl" align="right">
##### شکل 2.1 رابطه بین پارامترها و آرگومان‌های متد
</div>

<div dir="rtl" align="right">
مقادیر آرگومان‌ها به عنوان مقادیر اولیه برای پارامترها در داخل متد استفاده می‌شوند. در جنریک‌ها، شما پارامترهای نوع و آرگومان‌های نوع دارید که همان ایده هستند اما در مورد انواع (types) به کار می‌روند. اعلان یک نوع یا متد جنریک شامل پارامترهای نوع در براکت‌های زاویه‌ای (angle brackets) بعد از نام است. در داخل بدنه اعلان، کد می‌تواند از پارامتر نوع به عنوان یک نوع عادی استفاده کند (فقط یکی که اطلاعات زیادی در مورد آن ندارد).
</div>

<div dir="rtl" align="right">
کدی که از نوع یا متد جنریک استفاده می‌کند، سپس آرگومان‌های نوع را در براکت‌های زاویه‌ای بعد از نام نیز مشخص می‌کند. شکل 2.2 این رابطه را در زمینه `List<T>` نشان می‌دهد.
</div>

<div dir="rtl" align="right">
آرگومان برای پارامتر "name"
آرگومان برای پارامتر "value"
پارامترها
</div>

```csharp
public static void Method(string name, int value) { ... }
...
string customerName = "Jon";
Method(customerName, 5);
```

```csharp
public class List<T>
{
...
}
...
List<string> list = new List<string>();
```

<div dir="rtl" align="right">
پارامتر نوع (Type parameter)
آرگومان‌های نوع (Type arguments)
</div>

<div dir="rtl" align="right">
##### شکل 2.2 رابطه بین پارامترهای نوع و آرگومان‌های نوع
</div>

<div dir="rtl" align="right">
اکنون API (رابط برنامه‌نویسی کاربردی) کامل `List<T>` را تصور کنید: تمام امضاهای متدها (method signatures)، ویژگی‌ها (properties) و غیره. اگر از متغیر `list` که در شکل نشان داده شده است استفاده می‌کنید، هر `T` که در API ظاهر می‌شود، به `string` تبدیل می‌شود. به عنوان مثال، متد `Add` در `List<T>` دارای امضای زیر است:
</div>

```csharp
public void Add(T item)
```

<div dir="rtl" align="right">
اما اگر `list.Add(` را در ویژوال استودیو (Visual Studio) تایپ کنید، IntelliSense به شما پیشنهاد می‌دهد که گویی پارامتر `item` با نوع `string` اعلان شده است. اگر سعی کنید آرگومانی از نوع دیگر را ارسال کنید، منجر به خطای زمان کامپایل (compile-time error) خواهد شد.
</div>

<div dir="rtl" align="right">
اگرچه شکل 2.2 به یک کلاس جنریک (generic class) اشاره دارد، متدها (methods) نیز می‌توانند جنریک باشند. متد، پارامترهای نوع (type parameters) را اعلان می‌کند، و آن پارامترهای نوع می‌توانند در سایر قسمت‌های امضای متد (method signature) استفاده شوند. پارامترهای نوع متد اغلب به عنوان آرگومان‌های نوع (type arguments) برای انواع دیگر در امضا استفاده می‌شوند. لیست زیر راه حلی را برای متدی نشان می‌دهد که قبلاً نمی‌توانستید پیاده‌سازی کنید: چیزی برای ایجاد یک کالکشن (collection) جدید حاوی N عنصر اول از یک کالکشن موجود، اما به روشی با نوع‌دهی استاتیک (statically typed).
</div>

```csharp
public static List<T> CopyAtMost<T>(
    List<T> input, int maxElements)
{
    int actualCount = Math.Min(input.Count, maxElements);
    List<T> ret = new List<T>(actualCount);
    for (int i = 0; i < actualCount; i++)
    {
        ret.Add(input[i]);
    }
    return ret;
}

static void Main()
{
    List<int> numbers = new List<int>();
    numbers.Add(5);
    numbers.Add(10);
    numbers.Add(20);
    List<int> firstTwo = CopyAtMost<int>(numbers, 2);
    Console.WriteLine(firstTwo.Count);
}
```

<div dir="rtl" align="right">
لیست 2.5 کپی کردن عناصر از یک کالکشن به دیگری
</div>

<div dir="rtl" align="right">
بسیاری از متدهای جنریک (generic methods) از پارامتر نوع (type parameter) فقط یک بار در امضا استفاده می‌کنند و بدون اینکه آرگومان نوعی (type argument) برای انواع جنریک باشند. اما توانایی استفاده از یک پارامتر نوع برای بیان رابطه بین انواع پارامترهای معمولی (regular parameters) و نوع بازگشتی (return type)، بخش بزرگی از قدرت جنریک‌ها است.
</div>

<div dir="rtl" align="right">
*متد یک پارامتر نوع T را اعلان می‌کند و از آن در پارامترها و نوع بازگشتی استفاده می‌کند.*
*پارامتر نوع استفاده شده در بدنه متد*
*فراخوانی متد با استفاده از int به عنوان پارامتر نوع*
</div>


<div dir="rtl" align="right">
### 28 فصل 2 C# 2
</div>

<div dir="rtl" align="right">
به همین ترتیب، انواع جنریک (generic types) می‌توانند از پارامترهای نوع خود (type parameters) به عنوان آرگومان‌های نوع (type arguments) هنگام اعلان یک کلاس پایه (base class) یا یک رابط پیاده‌سازی شده (implemented interface) استفاده کنند. به عنوان مثال، نوع `List<T>` رابط `IEnumerable<T>` را پیاده‌سازی می‌کند، بنابراین اعلان کلاس می‌تواند به این صورت نوشته شود:
</div>

```csharp
public class List<T> : IEnumerable<T>
```

<div dir="rtl" align="right">
نکته: در واقع، `List<T>` چندین رابط را پیاده‌سازی می‌کند؛ این یک شکل ساده شده است.
</div>

<div dir="rtl" align="right">
#### arity انواع و متدهای جنریک
</div>

<div dir="rtl" align="right">
انواع یا متدهای جنریک می‌توانند چندین پارامتر نوع را با جدا کردن آن‌ها با کاما در داخل براکت‌های زاویه‌ای (angle brackets) اعلان کنند. به عنوان مثال، معادل جنریک کلاس `Hashtable` در NET 1. به این صورت اعلان می‌شود:
</div>

```csharp
public class Dictionary<TKey, TValue>
```

<div dir="rtl" align="right">
`arity` جنریک یک اعلان، تعداد پارامترهای نوعی است که دارد. صادقانه بگویم، این اصطلاحی است که بیشتر برای نویسندگان مفید است تا در استفاده روزمره هنگام نوشتن کد، اما من معتقدم هنوز ارزش دانستن را دارد. می‌توانید یک اعلان غیرجنریک را به عنوان اعلانی با `arity` جنریک 0 در نظر بگیرید.
</div>

<div dir="rtl" align="right">
`arity` جنریک یک اعلان به طور موثر بخشی از چیزی است که آن را منحصر به فرد می‌کند. به عنوان مثال، من قبلاً به رابط `IEnumerable<T>` معرفی شده در NET 2.0 اشاره کردم، اما این یک نوع متمایز از رابط `IEnumerable` غیرجنریک بود که قبلاً بخشی از NET 1.0 بود. به همین ترتیب، می‌توانید متدهایی با نام مشابه اما `arity` جنریک متفاوت بنویسید، حتی اگر امضای آنها یکسان باشد:
</div>

```csharp
public void Method() {}
public void Method<T>() {}
public void Method<T1, T2>() {}
```

<div dir="rtl" align="right">
هنگام اعلان انواع با `arity` جنریک متفاوت، انواع نیازی به هم‌نوع بودن ندارند، اگرچه معمولاً اینطور هستند. به عنوان یک مثال افراطی، این اعلان‌های نوع را در نظر بگیرید که همگی می‌توانند در یک اسمبلی بسیار گیج‌کننده همزیستی داشته باشند:
</div>

```csharp
public enum IAmConfusing {}
public class IAmConfusing<T> {}
public struct IAmConfusing<T1, T2> {}
public delegate void IAmConfusing<T1, T2, T3> {}
public interface IAmConfusing<T1, T2, T3, T4> {}
```

<div dir="rtl" align="right">
اگرچه من به شدت کدی مانند بالا را توصیه نمی‌کنم، یک الگوی نسبتاً رایج این است که یک کلاس استاتیک غیرجنریک (nongeneric static class) متدهای کمکی (helper methods) را ارائه دهد که به سایر انواع جنریک با نام مشابه ارجاع می‌دهند (برای اطلاعات بیشتر در مورد کلاس‌های استاتیک به بخش 2.5.2 مراجعه کنید). به عنوان مثال، در بخش 2.1.4 کلاس `Tuple` را خواهید دید که برای ایجاد نمونه‌هایی از کلاس‌های `Tuple` جنریک مختلف استفاده می‌شود.
</div>

<div dir="rtl" align="right">
*متد غیر جنریک (arity جنریک 0)*
*متد با arity جنریک 1*
*متد با arity جنریک 2*
</div>


<div dir="rtl" align="right">
### جنریک‌ها 29
</div>

<div dir="rtl" align="right">
همانطور که چندین نوع می‌توانند نام یکسانی داشته باشند اما `arity` جنریک متفاوتی داشته باشند، متدهای جنریک (generic methods) نیز می‌توانند. این مانند ایجاد سربارها (overloads) بر اساس پارامترها است، با این تفاوت که اینجا سربار بر اساس تعداد پارامترهای نوع (type parameters) است. توجه داشته باشید که اگرچه `arity` جنریک اعلان‌ها را از هم جدا نگه می‌دارد، نام پارامترهای نوع این کار را نمی‌کنند. به عنوان مثال، نمی‌توانید دو متد را به این صورت اعلان کنید:
</div>

```csharp
public void Method<TFirst>() {}
public void Method<TSecond>() {}
```

<div dir="rtl" align="right">
این‌ها دارای امضاهای (signatures) معادل در نظر گرفته می‌شوند، بنابراین تحت قوانین عادی سربارگذاری متد (method overloading) مجاز نیستند. می‌توانید سربارهای متدی را بنویسید که از نام‌های پارامتر نوع مختلف استفاده می‌کنند تا زمانی که متدها از راه‌های دیگر (مانند تعداد پارامترهای معمولی) متفاوت باشند، اگرچه من هرگز به یاد نمی‌آورم که بخواهم چنین کاری انجام دهم.
</div>

<div dir="rtl" align="right">
در حالی که در مورد چندین پارامتر نوع صحبت می‌کنیم، نمی‌توانید به دو پارامتر نوع در یک اعلان نام مشابه بدهید، همانطور که نمی‌توانید دو پارامتر معمولی را با نام مشابه اعلان کنید. به عنوان مثال، نمی‌توانید متدی را به این صورت اعلان کنید:
</div>

```csharp
public void Method<T, T>() {}
```

<div dir="rtl" align="right">
با این حال، خوب است که دو آرگومان نوع (type arguments) یکسان باشند، و اغلب همین چیزی است که شما می‌خواهید. به عنوان مثال، برای ایجاد یک نگاشت رشته به رشته، ممکن است از یک `Dictionary<string, string>` استفاده کنید.
</div>

<div dir="rtl" align="right">
مثال قبلی `IAmConfusing` از یک `enum` به عنوان نوع غیرجنریک (nongeneric type) استفاده کرد. این تصادفی نبود، زیرا می‌خواستم از آن برای نشان دادن نکته بعدی خود استفاده کنم.
</div>

<div dir="rtl" align="right">
*خطای زمان کامپایل؛ نمی‌توان فقط با نام پارامتر نوع سربارگذاری کرد.*
*خطای زمان کامپایل؛ پارامتر نوع `T` تکراری است.*
</div>

<div dir="rtl" align="right">
### 30 فصل 2 C# 2
</div>

<div dir="rtl" align="right">
به عنوان مثالی از اینکه چگونه ممکن است وسوسه شوید یک فیلد (field) را جنریک (generic) بدانید حتی اگر اینطور نباشد، این کلاس جنریک را در نظر بگیرید:
</div>

```csharp
public class ValidatingList<TItem>
{
    private readonly List<TItem> items = new List<TItem>();
}
```

<div dir="rtl" align="right">
من پارامتر نوع (type parameter) را `TItem` نامگذاری کرده‌ام تا به سادگی آن را از پارامتر نوع `T` در `List<T>` متمایز کنم. در اینجا، فیلد `items` از نوع `List<TItem>` است. این از پارامتر نوع `TItem` به عنوان آرگومان نوع (type argument) برای `List<T>` استفاده می‌کند، اما این یک پارامتر نوع است که توسط اعلان کلاس معرفی شده است، نه توسط اعلان فیلد.
</div>

<div dir="rtl" align="right">
برای بیشتر این موارد، تصور اینکه چگونه عضو می‌تواند جنریک باشد دشوار است. با این حال، گاهی اوقات می‌خواستم یک سازنده (constructor) یا ایندکسر (indexer) جنریک بنویسم، و پاسخ تقریباً همیشه این است که به جای آن یک متد جنریک بنویسید.
</div>

<div dir="rtl" align="right">
صحبت از متدهای جنریک، من قبلاً فقط یک توصیف ساده از آرگومان‌های نوع را ارائه کردم، زمانی که نحوه فراخوانی متدهای جنریک را توضیح می‌دادم. در برخی موارد، کامپایلر می‌تواند آرگومان‌های نوع را برای یک فراخوانی بدون نیاز به ارائه آن‌ها در کد منبع (source code) تعیین کند.
</div>

<div dir="rtl" align="right">
#### 2.1.4 استنتاج نوع (Type inference) برای آرگومان‌های نوع متدها
</div>

<div dir="rtl" align="right">
بیایید به بخش‌های حیاتی لیست 2.5 نگاهی بیندازیم. شما یک متد جنریک (generic method) دارید که به این صورت اعلان شده است:
</div>

```csharp
public static List<T> CopyAtMost<T>(List<T> input, int maxElements)
```

<div dir="rtl" align="right">
سپس، در متد `Main`، یک متغیر از نوع `List<int>` اعلان می‌کنید و سپس از آن به عنوان آرگومان (argument) برای متد استفاده می‌کنید:
</div>

```csharp
List<int> numbers = new List<int>();
...
List<int> firstTwo = CopyAtMost<int>(numbers, 2);
```

<div dir="rtl" align="right">
من در اینجا فراخوانی متد (method call) را برجسته کرده‌ام. شما برای فراخوانی `CopyAtMost` به یک آرگومان نوع نیاز دارید، زیرا این متد دارای یک پارامتر نوع (type parameter) است. اما نیازی نیست که آن آرگومان نوع را در کد منبع (source code) مشخص کنید. می‌توانید آن کد را به صورت زیر بازنویسی کنید:
</div>

```csharp
List<int> numbers = new List<int>();
...
List<int> firstTwo = CopyAtMost(numbers, 2);
```

<div dir="rtl" align="right">
این دقیقاً همان فراخوانی متد است از نظر IL (زبان میانی) که کامپایلر تولید خواهد کرد. اما شما مجبور نبودید آرگومان نوع `int` را مشخص کنید؛ کامپایلر آن را برای شما استنتاج کرد. این کار را بر اساس آرگومان شما برای اولین پارامتر در متد انجام داد. شما از آرگومان از نوع `List<int>` به عنوان مقدار برای پارامتر از نوع `List<T>` استفاده می‌کنید، بنابراین `T` باید `int` باشد.
</div>

<div dir="rtl" align="right">
*بسیاری از اعضای دیگر*
</div>


<div dir="rtl" align="right">
### جنریک‌ها 31
</div>

<div dir="rtl" align="right">
استنتاج نوع (Type inference) فقط می‌تواند از آرگومان‌هایی که به یک متد ارسال می‌کنید استفاده کند، نه آنچه با نتیجه انجام می‌دهید. همچنین باید کامل باشد؛ شما یا باید صراحتاً تمام آرگومان‌های نوع را مشخص کنید یا هیچ کدام را.
</div>

<div dir="rtl" align="right">
اگرچه استنتاج نوع فقط برای متدها کاربرد دارد، می‌توان از آن برای ساخت آسان‌تر نمونه‌هایی از انواع جنریک (generic types) استفاده کرد. به عنوان مثال، خانواده انواع `Tuple` را که در NET 4.0 معرفی شد، در نظر بگیرید. این شامل یک کلاس استاتیک `Tuple` غیرجنریک و چندین کلاس جنریک است: `Tuple<T1>`, `Tuple<T1, T2>`, `Tuple<T1, T2, T3>` و غیره. کلاس استاتیک مجموعه‌ای از متدهای کارخانه‌ای (factory methods) سربارگذاری شده (overloaded) `Create` را به این صورت دارد:
</div>

```csharp
public static Tuple<T1> Create<T1>(T1 item1)
{
    return new Tuple<T1>(item1);
}

public static Tuple<T1, T2> Create<T1, T2>(T1 item1, T2 item2)
{
    return new Tuple<T1, T2>(item1, item2);
}
```

<div dir="rtl" align="right">
اینها به نظر بی‌هدف و پیش پا افتاده می‌آیند، اما اجازه می‌دهند از استنتاج نوع در جایی استفاده شود که در غیر این صورت آرگومان‌های نوع باید هنگام ایجاد تاپل‌ها صراحتاً مشخص شوند. به جای این:
</div>

```csharp
new Tuple<int, string, int>(10, "x", 20)
```

<div dir="rtl" align="right">
می‌توانید این را بنویسید:
</div>

```csharp
Tuple.Create(10, "x", 20)
```

<div dir="rtl" align="right">
این یک تکنیک قدرتمند است که باید از آن آگاه باشید؛ به طور کلی پیاده‌سازی آن ساده است و می‌تواند کار با کد جنریک را بسیار دلپذیرتر کند.
</div>

<div dir="rtl" align="right">
من قصد ندارم وارد جزئیات نحوه عملکرد استنتاج نوع جنریک شوم. این در طول زمان بسیار تغییر کرده است، زیرا طراحان زبان راه‌هایی برای کارکرد آن در موارد بیشتر پیدا می‌کنند. تفکیک سربار (Overload resolution) و استنتاج نوع ارتباط نزدیکی با هم دارند و با انواع دیگر ویژگی‌ها (مانند وراثت (inheritance)، تبدیل‌ها (conversions) و پارامترهای اختیاری (optional parameters) در C# 4) تلاقی پیدا می‌کنند. این حوزه‌ای از مشخصات است که من آن را پیچیده‌ترین می‌دانم، و در اینجا نمی‌توانم به آن حق مطلب را ادا کنم.
</div>

<div dir="rtl" align="right">
خوشبختانه، این یکی از مواردی است که درک جزئیات آن در کدنویسی روزمره چندان کمکی نمی‌کند. در هر موقعیت خاص، سه احتمال وجود دارد:
* استنتاج نوع موفق می‌شود و نتیجه مورد نظر شما را می‌دهد. هورا.
* استنتاج نوع موفق می‌شود اما نتیجه‌ای را به شما می‌دهد که نمی‌خواستید. فقط آرگومان‌های نوع را صراحتاً مشخص کنید یا برخی از آرگومان‌ها را تبدیل کنید. به عنوان مثال، اگر می‌خواستید یک `Tuple<int, object, int>` از فراخوانی `Tuple.Create` قبلی داشته باشید،
</div>

<div dir="rtl" align="right">
من تنها نیستم. در زمان نگارش این کتاب، مشخصات برای حل سربار شکسته است. تلاش‌ها برای رفع آن برای استاندارد C# 5 ECMA شکست خورد؛ ما قصد داریم دوباره برای ویرایش بعدی تلاش کنیم.
</div>

<div dir="rtl" align="right">
### 32 فصل 2 C# 2
</div>

<div dir="rtl" align="right">
می‌توانستید آرگومان‌های نوع را به `Tuple.Create` صراحتاً مشخص کنید یا فقط `new Tuple<int, object, int>(...)` را فراخوانی کنید یا `Tuple.Create(10, (object)"x", 20)` را فراخوانی کنید.
* استنتاج نوع در زمان کامپایل (compile time) با شکست مواجه می‌شود. گاهی اوقات می‌توان این مشکل را با تبدیل (casting) برخی از آرگومان‌های شما برطرف کرد. به عنوان مثال، لیترال `null` (null literal) نوعی ندارد، بنابراین استنتاج نوع برای `Tuple.Create(null, 50)` شکست می‌خورد اما برای `Tuple.Create((string)null, 50)` موفق می‌شود. در مواقع دیگر فقط باید آرگومان‌های نوع را صراحتاً مشخص کنید.
</div>

<div dir="rtl" align="right">
در دو مورد آخر، گزینه‌ای که انتخاب می‌کنید به ندرت تفاوت زیادی در خوانایی ایجاد می‌کند. درک جزئیات استنتاج نوع می‌تواند پیش‌بینی اینکه چه چیزی کار می‌کند و چه چیزی کار نمی‌کند را آسان‌تر کند، اما بعید است که زمان صرف شده برای مطالعه مشخصات را جبران کند. اگر کنجکاو هستید، هرگز کسی را از خواندن مشخصات منصرف نمی‌کنم. فقط تعجب نکنید وقتی متوجه شدید که بین یک هزارتوی از گذرگاه‌های پیچ در پیچ کوچک، همه شبیه هم، و یک هزارتوی از گذرگاه‌های پیچ در پیچ کوچک، همه متفاوت، تغییر می‌کند.
</div>

<div dir="rtl" align="right">
با این حال، این صحبت‌های نگران‌کننده در مورد جزئیات پیچیده زبان نباید از راحتی استنتاج نوع بکاهد. C# به دلیل وجود آن بسیار آسان‌تر است.
</div>

<div dir="rtl" align="right">
تاکنون، تمام پارامترهای نوعی (type parameters) که درباره آن‌ها صحبت کردیم، بدون محدودیت (unconstrained) بودند. آن‌ها می‌توانستند به جای هر نوعی قرار بگیرند. اما همیشه این چیزی نیست که شما می‌خواهید؛ گاهی اوقات، فقط می‌خواهید انواع خاصی به عنوان آرگومان‌های نوع (type arguments) برای یک پارامتر نوع خاص استفاده شوند. اینجا جایی است که محدودیت‌های نوع (type constraints) به کار می‌آیند.
</div>

<div dir="rtl" align="right">
#### 2.1.5 محدودیت‌های نوع (Type constraints)
</div>

<div dir="rtl" align="right">
هنگامی که یک پارامتر نوع (type parameter) توسط یک نوع یا متد جنریک (generic type or method) اعلان می‌شود، می‌تواند محدودیت‌های نوعی (type constraints) را نیز مشخص کند که انواع قابل ارائه به عنوان آرگومان‌های نوع (type arguments) را محدود می‌کند. فرض کنید می‌خواهید متدی بنویسید که لیستی از آیتم‌ها را قالب‌بندی کند و اطمینان حاصل کند که آن‌ها را در یک فرهنگ خاص (culture) به جای فرهنگ پیش‌فرض (default culture) نخ (thread) قالب‌بندی می‌کنید. رابط `IFormattable` یک متد `ToString(string, IFormatProvider)` مناسب را فراهم می‌کند، اما چگونه می‌توانید مطمئن شوید که یک لیست مناسب دارید؟ ممکن است انتظار امضایی (signature) مانند این را داشته باشید:
</div>

```csharp
static void PrintItems(List<IFormattable> items)
```

<div dir="rtl" align="right">
اما این تقریباً هرگز مفید نخواهد بود. به عنوان مثال، نمی‌توانستید یک `List<decimal>` را به آن ارسال کنید، حتی اگر `decimal` رابط `IFormattable` را پیاده‌سازی کند؛ یک `List<decimal>` قابل تبدیل به `List<IFormattable>` نیست.
</div>

<div dir="rtl" align="right">
نکته: دلایل این موضوع را عمیق‌تر در فصل 4، هنگامی که واریانس جنریک (generic variance) را در نظر می‌گیریم، بررسی خواهیم کرد. در حال حاضر، این را فقط به عنوان یک مثال ساده برای محدودیت‌ها در نظر بگیرید.
</div>

<div dir="rtl" align="right">
آنچه شما نیاز دارید بیان کنید این است که پارامتر لیستی از نوع عنصر خاصی است که در آن نوع عنصر رابط `IFormattable` را پیاده‌سازی می‌کند. بخش "برخی از انواع عناصر" نشان می‌دهد که ممکن است بخواهید متد را جنریک کنید، و "جایی که نوع عنصر رابط `IFormattable` را پیاده‌سازی می‌کند" دقیقاً قابلیتی است که محدودیت‌های نوع به ما می‌دهند. شما یک عبارت `where` را در انتهای اعلان متد اضافه می‌کنید، به این صورت:
</div>

```csharp
static void PrintItems<T>(List<T> items) where T : IFormattable
```

<div dir="rtl" align="right">
روشی که در اینجا `T` را محدود کرده‌اید، فقط مقادیری که می‌توانند به متد ارسال شوند را تغییر نمی‌دهد؛ بلکه آنچه را که می‌توانید با یک مقدار از نوع `T` در داخل متد انجام دهید را نیز تغییر می‌دهد. کامپایلر می‌داند که `T` رابط `IFormattable` را پیاده‌سازی می‌کند، بنابراین اجازه می‌دهد متد `IFormattable.ToString(string, IFormatProvider)` روی هر مقدار `T` فراخوانی شود.
</div>

```csharp
static void PrintItems<T>(List<T> items) where T : IFormattable
{
    CultureInfo culture = CultureInfo.InvariantCulture;
    foreach (T item in items)
    {
        Console.WriteLine(item.ToString(null, culture));
    }
}
```

<div dir="rtl" align="right">
بدون محدودیت‌های نوع، آن فراخوانی `ToString` کامپایل نمی‌شد؛ تنها متد `ToString` که کامپایلر برای `T` می‌شناخت، متدی بود که در `System.Object` اعلان شده بود.
</div>


<div dir="rtl" align="right">
محدودیت‌های نوع (Type constraints) فقط به رابط‌ها (interfaces) محدود نمی‌شوند. محدودیت‌های نوع زیر در دسترس هستند:
*   محدودیت نوع مرجع (Reference type constraint)— `where T : class`. آرگومان نوع (type argument) باید یک نوع مرجع (reference type) باشد. (فریب استفاده از کلمه کلیدی `class` را نخورید؛ می‌تواند هر نوع مرجعی باشد، از جمله رابط‌ها (interfaces) و دلیگیت‌ها (delegates).)
*   محدودیت نوع مقدار (Value type constraint)— `where T : struct`. آرگومان نوع باید یک نوع مقدار غیرقابل تهی (non-nullable value type) باشد (یا یک `struct` یا یک `enum`). انواع مقادیر `nullable` (توصیف شده در بخش 2.2) این محدودیت را ندارند.
*   محدودیت سازنده (Constructor constraint)— `where T : new()`. آرگومان نوع باید یک سازنده عمومی بدون پارامتر (public parameterless constructor) داشته باشد. این امکان استفاده از `new T()` را در داخل بدنه کد برای ساخت یک نمونه جدید از `T` فراهم می‌کند.
*   محدودیت تبدیل (Conversion constraint)— `where T : SomeType`. در اینجا، `SomeType` می‌تواند یک کلاس (class)، یک رابط (interface)، یا یک پارامتر نوع دیگر باشد که در اینجا نشان داده شده است:
    *   `where T : Control`
    *   `where T : IFormattable`
    *   `where T1 : T2`

قوانین نسبتاً پیچیده‌ای نشان می‌دهند که چگونه محدودیت‌ها می‌توانند با هم ترکیب شوند. به طور کلی، پیام خطای کامپایلر هنگام نقض این قوانین، مشکل را آشکار می‌کند.
</div>

<div dir="rtl" align="right">
لیست 2.6 چاپ آیتم‌ها در فرهنگ ثابت (invariant culture) با استفاده از محدودیت‌های نوع
</div>

<div dir="rtl" align="right">
### 34 فصل 2 C# 2
</div>

<div dir="rtl" align="right">
یک شکل جالب و نسبتاً رایج از محدودیت (constraint) از پارامتر نوع (type parameter) در خود محدودیت استفاده می‌کند:
</div>

```csharp
public void Sort(List<T> items) where T : IComparable<T>
```

<div dir="rtl" align="right">
این محدودیت از `T` به عنوان آرگومان نوع (type argument) برای رابط جنریک `IComparable<T>` استفاده می‌کند. این به متد مرتب‌سازی ما (sorting method) اجازه می‌دهد تا عناصر را از پارامتر `items` به صورت زوجی با استفاده از متد `CompareTo` از `IComparable<T>` مقایسه کند:
</div>

```csharp
T first = ...;
T second = ...;
int comparison = first.CompareTo(second);
```

<div dir="rtl" align="right">
من بیش از هر نوع دیگری از محدودیت‌های نوع مبتنی بر رابط (interface-based type constraints) استفاده کرده‌ام، اگرچه گمان می‌کنم آنچه شما استفاده می‌کنید تا حد زیادی به نوع کدی که می‌نویسید بستگی دارد.
</div>

<div dir="rtl" align="right">
هنگامی که چندین پارامتر نوع در یک اعلان جنریک وجود دارد، هر پارامتر نوع می‌تواند مجموعه‌ای کاملاً متفاوت از محدودیت‌ها داشته باشد، مانند مثال زیر:
</div>

```csharp
TResult Method<TArg, TResult>(TArg input)
where TArg : IComparable<TArg>
where TResult : class, new()
```

<div dir="rtl" align="right">
تور فشرده ما در مورد جنریک‌ها تقریباً به پایان رسیده است، اما چند موضوع دیگر برای توضیح دارم. با دو عملگر مرتبط با نوع (type-related operators) که در C# 2 موجود است، شروع خواهم کرد.
</div>

<div dir="rtl" align="right">
*متد جنریک با دو پارامتر نوع، `TArg` و `TResult`*
*`TArg` باید `IComparable<TArg>` را پیاده سازی کند.*
*`TResult` باید یک نوع مرجع با یک سازنده بدون پارامتر باشد.*
</div>

<div dir="rtl" align="right">
#### 2.1.6 عملگرهای `default` و `typeof`
</div>

<div dir="rtl" align="right">
C# 1 از قبل عملگر `typeof()` را داشت که نام یک نوع را به عنوان تنها عملوند (operand) خود می‌پذیرفت. C# 2 عملگر `default()` را اضافه کرد و استفاده از `typeof` را کمی گسترش داد.
</div>

<div dir="rtl" align="right">
عملگر `default` به راحتی قابل توضیح است. عملوند نام یک نوع یا پارامتر نوع (type parameter) است، و نتیجه مقدار پیش‌فرض (default value) برای آن نوع است - همان مقداری که اگر یک فیلد (field) را اعلان می‌کردید و بلافاصله به آن مقداری اختصاص نمی‌دادید، دریافت می‌کردید. برای انواع مرجع (reference types)، آن یک ارجاع `null` است؛ برای انواع مقادیر غیرقابل تهی (non-nullable value types)، آن مقدار "همه صفرها" است (0، 0.0، 0.0m، `false`، واحد کد UTF-16 با مقدار عددی 0 و غیره)؛ و برای انواع مقادیر `nullable` (nullable value types)، آن مقدار `null` برای نوع است.
</div>

<div dir="rtl" align="right">
عملگر `default` را می‌توان با پارامترهای نوع و با انواع جنریک (generic types) با آرگومان‌های نوع (type arguments) مناسب (که آن آرگومان‌ها نیز می‌توانند پارامترهای نوع باشند) استفاده کرد. به عنوان مثال، در یک متد جنریک که یک پارامتر نوع `T` را اعلان می‌کند، همه اینها معتبر هستند:
*   `default(T)`
*   `default(int)`
*   `default(string)`
*   `default(List<T>)`
*   `default(List<List<string>>)`
</div>

<div dir="rtl" align="right">
### جنریک‌ها 35
</div>

<div dir="rtl" align="right">
نوع عملگر `default` همان نوعی است که در داخل آن نامگذاری شده است. این عملگر بیشتر با پارامترهای نوع جنریک استفاده می‌شود، زیرا در غیر این صورت معمولاً می‌توانید مقدار پیش‌فرض را به روشی دیگر مشخص کنید. به عنوان مثال، ممکن است بخواهید از مقدار پیش‌فرض به عنوان مقدار اولیه برای یک متغیر محلی (local variable) استفاده کنید که ممکن است بعداً مقدار متفاوتی به آن اختصاص داده شود یا نشود. برای ملموس‌تر کردن این موضوع، در اینجا یک پیاده‌سازی ساده از متدی آورده شده است که ممکن است برای شما آشنا باشد:
</div>

```csharp
public T LastOrDefault(IEnumerable<T> source)
{
    T ret = default(T);
    foreach (T item in source)
    {
        ret = item;
    }
    return ret;
}
```

<div dir="rtl" align="right">
عملگر `typeof` کمی پیچیده‌تر است. چهار حالت کلی برای بررسی وجود دارد:
*   اصلاً جنریک درگیر نیست؛ به عنوان مثال، `typeof(string)`
*   جنریک درگیر است اما بدون پارامتر نوع؛ به عنوان مثال، `typeof(List<int>)`
*   فقط یک پارامتر نوع؛ به عنوان مثال، `typeof(T)`
*   جنریک درگیر است و از یک پارامتر نوع در عملوند استفاده می‌کند؛ به عنوان مثال، `typeof(List<TItem>)` در داخل یک متد جنریک که یک پارامتر نوع به نام `TItem` اعلان می‌کند.
*   جنریک درگیر است اما هیچ آرگومان نوعی در عملوند مشخص نشده است؛ به عنوان مثال، `typeof(List<>)`
</div>

<div dir="rtl" align="right">
اولین مورد از اینها ساده است و اصلاً تغییری نکرده است. همه موارد دیگر نیاز به مراقبت بیشتری دارند و آخرین مورد نوع جدیدی از سینتکس (syntax) را معرفی می‌کند. عملگر `typeof` هنوز تعریف شده است تا یک مقدار `Type` را برگرداند، بنابراین در هر یک از این موارد باید چه چیزی را برگرداند؟ کلاس `Type` برای درک جنریک‌ها تقویت شد. چندین موقعیت وجود دارد که باید در نظر گرفته شود؛ موارد زیر چند نمونه هستند:
</div>


<div dir="rtl" align="right">
*   اگر انواع را در داخل اسمبلی (assembly) حاوی `List<T>` لیست کنید، به عنوان مثال، انتظار دارید `List<T>` را بدون هیچ آرگومان نوع خاصی برای `T` دریافت کنید. این یک تعریف نوع جنریک (generic type definition) است.
*   اگر `GetType()` را روی یک شیء `List<int>` فراخوانی کنید، می‌خواهید نوعی را دریافت کنید که اطلاعاتی در مورد آرگومان نوع دارد.
*   اگر نوع پایه (base type) تعریف نوع جنریک یک کلاس را که به صورت زیر اعلان شده است بپرسید:
</div>

```csharp
class StringDictionary<T> : Dictionary<string, T>
```

<div dir="rtl" align="right">
در نهایت به نوعی با یک آرگومان نوع "کانکریت" (concrete) (`string`، برای پارامتر نوع `TKey` از `Dictionary<TKey, TValue>`) و یک آرگومان نوع که هنوز یک پارامتر نوع است (`T`، برای پارامتر نوع `TValue`) خواهید رسید.
</div>

<div dir="rtl" align="right">
صادقانه بگویم، همه چیز بسیار گیج‌کننده است، اما این ذاتی دامنه مسئله است. بسیاری از متدها و ویژگی‌ها در `Type` به شما اجازه می‌دهند از یک تعریف نوع جنریک به یک نوع با تمام آرگومان‌های نوع ارائه شده بروید، یا بالعکس، به عنوان مثال.
</div>

<div dir="rtl" align="right">
*یک متغیر محلی را اعلان کنید و مقدار پیش فرض T را به آن اختصاص دهید.*
*مقدار متغیر محلی را با مقدار فعلی در دنباله جایگزین کنید.*
*آخرین مقدار تخصیص یافته را برگردانید.*
</div>

<div dir="rtl" align="right">
### 36 فصل 2 C# 2
</div>

<div dir="rtl" align="right">
بیایید برگردیم به عملگر `typeof`. ساده‌ترین مثالی که می‌توان فهمید، `typeof(List<int>)` است. این `Type` را نشان می‌دهد که `List<T>` را با یک آرگومان نوع `int` نشان می‌دهد، درست مانند اینکه شما `new List<int>().GetType()` را فراخوانی کرده باشید.
</div>

<div dir="rtl" align="right">
مورد بعدی، `typeof(T)`، هر چه که آرگومان نوع `T` در آن نقطه از کد باشد را برمی‌گرداند. این همیشه یک نوع بسته و ساخته شده (closed, constructed type) خواهد بود، که روش مشخصات برای گفتن این است که یک نوع واقعی است که هیچ پارامتر نوعی در هیچ کجای آن دخیل نیست. اگرچه در اکثر موارد سعی می‌کنم اصطلاحات را به طور کامل توضیح دهم، اصطلاحات مربوط به جنریک‌ها (باز، بسته، ساخته شده، محدود، نامحدود) گیج‌کننده و تقریباً هرگز در زندگی واقعی مفید نیستند. ما بعداً باید در مورد انواع بسته و ساخته شده صحبت کنیم، اما به بقیه موارد نخواهم پرداخت.
</div>

<div dir="rtl" align="right">
آسان‌ترین راه برای نشان دادن منظورم در مورد `typeof(T)` این است که می‌توانید `typeof(List<T>)` را در همان مثال مشاهده کنید. لیست زیر یک متد جنریک (generic method) را اعلان می‌کند که نتیجه هر دو `typeof(T)` و `typeof(List<T>)` را در کنسول چاپ می‌کند و سپس آن متد را با دو آرگومان نوع مختلف فراخوانی می‌کند.
</div>

```csharp
static void PrintType<T>()
{
    Console.WriteLine("typeof(T) = {0}", typeof(T));
    Console.WriteLine("typeof(List<T>) = {0}", typeof(List<T>));
}

static void Main()
{
    PrintType<string>();
    PrintType<int>();
}
```

<div dir="rtl" align="right">
نتیجه لیست 2.7 در اینجا نشان داده شده است:
</div>

```
typeof(T) = System.String
typeof(List<T>) = System.Collections.Generic.List`1[System.String]
typeof(T) = System.Int32
typeof(List<T>) = System.Collections.Generic.List`1[System.Int32]
```

<div dir="rtl" align="right">
نکته مهم این است که وقتی در محیطی اجرا می‌شوید که آرگومان نوع برای `T` `string` است (در طول اولین فراخوانی)، نتیجه `typeof(T)` همانند `typeof(string)` است. به همین ترتیب، نتیجه `typeof(List<T>)` همانند نتیجه `typeof(List<string>)` است. وقتی متد را دوباره با `int` به عنوان آرگومان نوع فراخوانی می‌کنید، همان نتایج را برای `typeof(int)` و `typeof(List<int>)` دریافت می‌کنید. هر زمان که کد در یک نوع یا متد جنریک اجرا می‌شود، پارامتر نوع همیشه به یک نوع بسته و ساخته شده اشاره می‌کند.
</div>

<div dir="rtl" align="right">
یکی دیگر از نکات قابل توجه از این خروجی، فرمت نام یک نوع جنریک (generic type) هنگام استفاده از انعکاس (reflection) است. `List`1 نشان می‌دهد که این یک نوع جنریک به نام `List` با `arity` جنریک 1 (یک پارامتر نوع) است، و آرگومان‌های نوع در داخل براکت‌های مربعی بعد از آن نشان داده شده‌اند.
</div>

<div dir="rtl" align="right">
لیست 2.7 چاپ نتیجه عملگر `typeof`
</div>

<div dir="rtl" align="right">
*هم `typeof(T)` و هم `typeof(List<T>)` را چاپ می‌کند.*
*متد را با یک آرگومان نوع `string` فراخوانی می‌کند.*
*متد را با یک آرگومان نوع `int` فراخوانی می‌کند.*
</div>

<div dir="rtl" align="right">
### جنریک‌ها 37
</div>

<div dir="rtl" align="right">
آخرین مورد در لیست قبلی ما `typeof(List<>)` بود. به نظر می‌رسد که این مورد به طور کامل یک آرگومان نوع را ندارد. این سینتکس (syntax) فقط در عملگر `typeof` معتبر است و به تعریف نوع جنریک (generic type definition) اشاره دارد. سینتکس برای انواع با `arity` جنریک 1 فقط `TypeName<>` است؛ برای هر پارامتر نوع اضافی، یک کاما در داخل براکت‌های زاویه‌ای اضافه می‌کنید. برای به دست آوردن تعریف نوع جنریک برای `Dictionary<TKey, TValue>`، از `typeof(Dictionary<,>)` استفاده می‌کنید. برای به دست آوردن تعریف برای `Tuple<T1, T2, T3>`، از `typeof(Tuple<,,>)` استفاده می‌کنید.
</div>

<div dir="rtl" align="right">
درک تفاوت بین تعریف نوع جنریک و یک نوع بسته و ساخته شده برای موضوع نهایی ما بسیار مهم است: نحوه مقداردهی اولیه انواع و نحوه مدیریت حالت در سطح نوع (static).
</div>

<div dir="rtl" align="right">
#### 2.1.7 مقداردهی اولیه و حالت نوع جنریک
</div>

<div dir="rtl" align="right">
همانطور که هنگام استفاده از عملگر `typeof` دیدید، `List<int>` و `List<string>` به طور موثری انواع متفاوتی هستند که از یک تعریف نوع جنریک (generic type definition) ساخته شده‌اند. این فقط در مورد نحوه استفاده شما از انواع صادق نیست، بلکه در مورد نحوه مقداردهی اولیه انواع و نحوه مدیریت فیلدهای استاتیک (static fields) نیز صادق است. هر نوع بسته و ساخته شده (closed, constructed type) به طور جداگانه مقداردهی اولیه می‌شود و مجموعه مستقل خود از فیلدهای استاتیک را دارد. لیست زیر این را با یک شمارنده جنریک (generic counter) ساده (و ناامن در برابر ریسه) نشان می‌دهد.
</div>

```csharp
class GenericCounter<T>
{
    private static int value;

    static GenericCounter()
    {
        Console.WriteLine("Initializing counter for {0}", typeof(T));
    }

    public static void Increment()
    {
        value++;
    }

    public static void Display()
    {
        Console.WriteLine("Counter for {0}: {1}", typeof(T), value);
    }
}

class GenericCounterDemo
{
    static void Main()
    {
        GenericCounter<string>.Increment();
        GenericCounter<string>.Increment();
        GenericCounter<string>.Display();
        GenericCounter<int>.Display();
        GenericCounter<int>.Increment();
        GenericCounter<int>.Display();
    }
}
```

<div dir="rtl" align="right">
لیست 2.8 بررسی فیلدهای استاتیک در انواع جنریک
</div>

<div dir="rtl" align="right">
*یک فیلد برای هر نوع بسته و ساخته شده*
*مقداردهی اولیه برای `GenericCounter<string>` را آغاز می‌کند.*
*مقداردهی اولیه برای `GenericCounter<int>` را آغاز می‌کند.*
</div>

<div dir="rtl" align="right">
### 38 فصل 2 C# 2
</div>

<div dir="rtl" align="right">
خروجی لیست 2.8 به شرح زیر است:
</div>

```
Initializing counter for System.String
Counter for System.String: 2
Initializing counter for System.Int32
Counter for System.Int32: 0
Counter for System.Int32: 1
```

<div dir="rtl" align="right">
در این خروجی دو نتیجه برای تمرکز وجود دارد. اولاً، مقدار `GenericCounter<string>` مستقل از `GenericCounter<int>` است. ثانیاً، سازنده استاتیک (static constructor) دو بار اجرا می‌شود: یک بار برای هر نوع بسته و ساخته شده (closed, constructed type). اگر سازنده استاتیک نداشتید، تضمین‌های زمانی کمتری برای اینکه دقیقاً چه زمانی هر نوع مقداردهی اولیه می‌شود وجود داشت، اما اساساً می‌توانید `GenericCounter<string>` و `GenericCounter<int>` را به عنوان انواع مستقل در نظر بگیرید.
</div>

<div dir="rtl" align="right">
برای پیچیده‌تر کردن موضوع، انواع جنریک می‌توانند در داخل انواع جنریک دیگر قرار بگیرند. هنگامی که این اتفاق می‌افتد، برای هر ترکیب آرگومان نوع (type arguments) یک نوع جداگانه وجود دارد. به عنوان مثال، کلاس‌هایی مانند این را در نظر بگیرید:
</div>

```csharp
class Outer<TOuter>
{
    class Inner<TInner>
    {
        static int value;
    }
}
```

<div dir="rtl" align="right">
با استفاده از `int` و `string` به عنوان آرگومان‌های نوع، انواع زیر مستقل هستند و هر یک فیلد `value` خود را دارند:
*   `Outer<string>.Inner<string>`
*   `Outer<string>.Inner<int>`
*   `Outer<int>.Inner<string>`
*   `Outer<int>.Inner<int>`

در بیشتر کدها این اتفاق نسبتاً نادر است، و زمانی که می‌دانید آنچه مهم است، نوع کاملاً مشخص شده (fully specified type) است، از جمله هر گونه آرگومان نوع برای هر دو نوع برگ و هر نوع احاطه‌کننده (enclosing types)، به راحتی قابل مدیریت است.
</div>

<div dir="rtl" align="right">
این از جنریک‌ها بود، که تا کنون بزرگترین ویژگی در C# 2 و یک پیشرفت بزرگ نسبت به C# 1 است. موضوع بعدی ما انواع مقادیر `nullable` (nullable value types) هستند، که به شدت بر اساس جنریک‌ها بنا شده‌اند.
</div>


<div dir="rtl" align="right">
### 2.2 انواع مقادیر Nullable
</div>

<div dir="rtl" align="right">
تونی هوار در سال 1965 ارجاعات `null` را در الگول (Algol) معرفی کرد و متعاقباً آن را "اشتباه یک میلیارد دلاری" خود نامید. توسعه‌دهندگان بی‌شماری از اینکه کدشان `NullReferenceException` (در NET)، `NullPointerException` (در جاوا) یا موارد مشابه دیگر را پرتاب می‌کند، سرخورده شده‌اند. سوالات متعارف Stack Overflow با صدها سوال دیگر به آن‌ها اشاره دارند زیرا این یک مشکل بسیار رایج است. اگر `null` بودن اینقدر بد است، چرا در C# 2 و NET 2.0 به شکل
</div>

<div dir="rtl" align="right">
### انواع مقادیر Nullable 39
</div>

<div dir="rtl" align="right">
انواع مقادیر `nullable`، بیشتر از آن معرفی شد؟ قبل از اینکه به پیاده‌سازی این ویژگی بپردازیم، اجازه دهید مشکلی را که سعی در حل آن دارد و راه‌حل‌های قبلی را بررسی کنیم.
</div>

<div dir="rtl" align="right">
#### 2.2.1 هدف: بیان عدم وجود اطلاعات
</div>

<div dir="rtl" align="right">
گاهی اوقات مفید است که یک متغیر برای نمایش اطلاعاتی داشته باشیم، اما آن اطلاعات در هر شرایطی وجود نخواهد داشت. در اینجا چند مثال ساده آورده شده است:
*   شما در حال مدل‌سازی یک سفارش مشتری هستید، از جمله جزئیات شرکت، اما مشتری ممکن است سفارشی را از طرف یک شرکت ثبت نکند.
*   شما در حال مدل‌سازی یک شخص هستید، از جمله تاریخ تولد و تاریخ فوت او، اما ممکن است شخص هنوز زنده باشد.
*   شما در حال مدل‌سازی یک فیلتر برای محصولات هستید، از جمله محدوده قیمت، اما مشتری ممکن است حداکثر قیمت را مشخص نکرده باشد.
</div>

<div dir="rtl" align="right">
اینها همه یک شکل خاص از تمایل به نمایش عدم وجود یک مقدار هستند؛ شما می‌توانید اطلاعات کامل داشته باشید اما همچنان نیاز به مدل سازی عدم وجود آن دارید. در شرایط دیگر، ممکن است اطلاعات ناقصی داشته باشید. در مثال دوم، ممکن است تاریخ تولد فرد را ندانید نه به این دلیل که او متولد نشده، بلکه به این دلیل که سیستم شما آن اطلاعات را ندارد. گاهی اوقات باید تفاوت بین "معلوم بودن عدم وجود" و "نامعلوم" را در داده‌های خود نشان دهید، اما اغلب فقط عدم وجود اطلاعات کافی است.
</div>

<div dir="rtl" align="right">
برای انواع مرجع (reference types)، شما از قبل راهی برای نمایش عدم وجود اطلاعات دارید: یک ارجاع `null` (null reference). اگر یک کلاس `Company` دارید و کلاس `Order` شما به شرکتی که با سفارش مرتبط است ارجاع می‌دهد، می‌توانید آن را `null` قرار دهید اگر مشتری شرکتی را مشخص نکند.
</div>

<div dir="rtl" align="right">
برای انواع مقادیر (value types) در C# 1، معادل آن وجود نداشت. دو روش رایج برای نمایش این موضوع وجود داشت:
*   از یک مقدار رزرو شده برای نمایش داده‌های گمشده استفاده کنید. به عنوان مثال، ممکن است از `decimal.MaxValue` در یک فیلتر قیمت برای نمایش "حداکثر قیمت مشخص نشده" استفاده کنید.
*   یک پرچم `Boolean` جداگانه برای نشان دادن اینکه آیا فیلد دیگری دارای یک مقدار واقعی است یا باید نادیده گرفته شود، نگه دارید. تا زمانی که قبل از استفاده از فیلد دیگر پرچم را بررسی می‌کنید، مقدار آن در حالت عدم وجود نامربوط است.
</div>

<div dir="rtl" align="right">
هیچ یک از اینها ایده‌آل نیست. روش اول مجموعه مقادیر معتبر را کاهش می‌دهد (برای `decimal` چندان بد نیست اما برای `byte` که احتمال نیاز به دامنه کامل بیشتر است، مشکل‌سازتر است). روش دوم منجر به منطق خسته‌کننده و تکراری زیادی می‌شود.
</div>

<div dir="rtl" align="right">
مهم‌تر از آن، هر دو مستعد خطا هستند. هر دو شما را ملزم می‌کنند قبل از استفاده از مقداری که ممکن است معتبر باشد یا نباشد، بررسی انجام دهید. اگر آن بررسی را انجام ندهید، کد شما با استفاده از داده‌های نامناسب ادامه خواهد یافت. به طور بی‌صدا کار اشتباهی انجام می‌دهد و به احتمال زیاد اشتباه را به سایر قسمت‌های سیستم منتقل می‌کند. شکست بی‌صدا بدترین نوع است، زیرا ردیابی و بازگرداندن آن می‌تواند دشوار باشد. من استثنائات بلند و واضح را ترجیح می‌دهم که کد شکسته را در مسیر خود متوقف کنند.
</div>

<div dir="rtl" align="right">
انواع مقادیر `Nullable`، روش دوم نشان داده شده قبلی را کپسوله‌سازی می‌کنند: آنها یک پرچم اضافی را همراه با مقدار نگه می‌دارند تا بگویند آیا باید استفاده شود یا خیر. کپسوله‌سازی در اینجا کلیدی است؛ ساده‌ترین راه برای استفاده از مقدار نیز یک راه ایمن است زیرا اگر سعی کنید به طور نامناسب از آن استفاده کنید، یک استثنا ایجاد می‌کند. استفاده مداوم از یک نوع واحد برای نمایش یک مقدار که ممکن است وجود نداشته باشد، زبان را قادر می‌سازد تا زندگی ما را آسان‌تر کند، و نویسندگان کتابخانه نیز راهی اصطلاحی برای نمایش آن در سطح API خود دارند.
</div>

<div dir="rtl" align="right">
با کنار گذاشتن آن مقدمه مفهومی، بیایید ببینیم که چارچوب و CLR چه چیزی را از نظر انواع مقادیر `nullable` ارائه می‌دهند. پس از ایجاد آن پایه، ویژگی‌های اضافی C# را به شما نشان خواهم داد که کار با آنها را آسان می‌کند.
</div>

<div dir="rtl" align="right">
#### 2.2.2 پشتیبانی CLR و چارچوب: `struct Nullable<T>`
</div>

<div dir="rtl" align="right">
هسته اصلی پشتیبانی از انواع مقادیر `Nullable`، ساختار `Nullable<T>` است. یک نسخه ابتدایی از `Nullable<T>` به این صورت خواهد بود:
</div>

```csharp
public struct Nullable<T> where T : struct
{
    private readonly T value;
    private readonly bool hasValue;

    public Nullable(T value)
    {
        this.value = value;
        this.hasValue = true;
    }

    public bool HasValue { get { return hasValue; } }

    public T Value
    {
        get
        {
            if (!hasValue)
            {
                throw new InvalidOperationException();
            }
            return value;
        }
    }
}
```

<div dir="rtl" align="right">
همانطور که می‌بینید، تنها سازنده اعلان شده، `hasValue` را به `true` تنظیم می‌کند، اما مانند همه ساختارها، یک سازنده ضمنی بدون پارامتر (implicit parameterless constructor) وجود دارد که `hasValue` را به صورت `false` و `value` را به عنوان مقدار پیش‌فرض `T` باقی می‌گذارد:
</div>

```csharp
Nullable<int> nullable = new Nullable<int>();
Console.WriteLine(nullable.HasValue);
```

<div dir="rtl" align="right">
*ساختار جنریک با `T` محدود شده*
*به عنوان یک نوع مقدار غیرقابل تهی*
*سازنده برای ارائه یک مقدار*
*خاصیت برای بررسی وجود*
*یک مقدار واقعی*
*دسترسی به مقدار،*
*در صورت عدم وجود*
*استثنا ایجاد می‌شود*
*`False` را چاپ می‌کند.*
</div>

<div dir="rtl" align="right">
### انواع مقادیر Nullable 41
</div>

<div dir="rtl" align="right">
محدودیت `where T : struct` در `Nullable<T>` به `T` اجازه می‌دهد تا هر نوع مقداری (value type) باشد به جز یک `Nullable<T>` دیگر. این با انواع اولیه (primitive types)، `enum`ها، ساختارهای ارائه شده توسط سیستم و ساختارهای تعریف شده توسط کاربر کار می‌کند. تمام موارد زیر معتبر هستند:
*   `Nullable<int>`
*   `Nullable<FileMode>`
*   `Nullable<Guid>`
*   `Nullable<LocalDate>` (از Noda Time)
</div>

<div dir="rtl" align="right">
اما موارد زیر نامعتبر هستند:
*   `Nullable<string>` (`string` یک نوع مرجع است)
*   `Nullable<int[]>` (آرایه‌ها انواع مرجع هستند، حتی اگر نوع عنصر یک نوع مقدار باشد)
*   `Nullable<ValueType>` (خود `ValueType` یک نوع مقدار نیست)
*   `Nullable<Enum>` (خود `Enum` یک نوع مقدار نیست)
*   `Nullable<Nullable<int>>` (`Nullable<int>` قابل تهی است)
*   `Nullable<Nullable<Nullable<int>>>` (تلاش برای تو در تو کردن بیشتر `Nullable` کمکی نمی‌کند)
</div>

<div dir="rtl" align="right">
نوع `T` به عنوان نوع زیربنایی `Nullable<T>` نیز شناخته می‌شود. به عنوان مثال، نوع زیربنایی `Nullable<int>`، `int` است.
</div>

<div dir="rtl" align="right">
فقط با وجود این بخش و بدون هیچ پشتیبانی اضافی از CLR، چارچوب یا زبان، می‌توانید به طور ایمن از `type` برای نمایش فیلتر حداکثر قیمت استفاده کنید:
</div>

```csharp
public void DisplayMaxPrice(Nullable<decimal> maxPriceFilter)
{
    if (maxPriceFilter.HasValue)
    {
        Console.WriteLine("Maximum price: {0}", maxPriceFilter.Value);
    }
    else
    {
        Console.WriteLine("No maximum price set.");
    }
}
```

<div dir="rtl" align="right">
این کد به خوبی رفتار می‌کند که قبل از استفاده از مقدار بررسی می‌کند، اما در مورد کد ضعیف نوشته شده که فراموش می‌کند ابتدا بررسی کند یا چیز اشتباهی را بررسی می‌کند، چطور؟ شما نمی‌توانید به طور تصادفی از یک مقدار نامناسب استفاده کنید؛ اگر سعی کنید به `maxPriceFilter.Value` دسترسی پیدا کنید در حالی که خاصیت `HasValue` آن `false` است، یک استثنا ایجاد می‌شود.
</div>

<div dir="rtl" align="right">
نکته: می‌دانم که قبلاً به این نکته اشاره کردم، اما فکر می‌کنم آنقدر مهم است که دوباره بیان کنم: پیشرفت فقط با آسان‌تر کردن نوشتن کد صحیح حاصل نمی‌شود؛ بلکه با سخت‌تر کردن نوشتن کد شکسته یا کاهش شدت پیامدها نیز حاصل می‌شود.
</div>

<div dir="rtl" align="right">
ساختار `Nullable<T>` دارای متدها و عملگرهای (operators) زیر نیز هست:
*   متد `GetValueOrDefault()` بدون پارامتر، مقدار را در ساختار یا مقدار پیش‌فرض (default value) برای نوع را برمی‌گرداند اگر `HasValue` برابر `false` باشد.
*   متد `GetValueOrDefault(T defaultValue)` پارامتردار، مقدار را در ساختار یا مقدار پیش‌فرض مشخص شده را برمی‌گرداند اگر `HasValue` برابر `false` باشد.
*   متدهای `Equals(object)` و `GetHashCode()` اعلان شده در `object` به روشی نسبتاً واضح `override` شده‌اند، ابتدا خاصیت‌های `HasValue` را مقایسه می‌کنند و سپس خاصیت‌های `Value` را برای برابری مقایسه می‌کنند اگر `HasValue` برای هر دو مقدار `true` باشد.
</div>


<div dir="rtl" align="right">
### فصل 2 C# 2
</div>

<div dir="rtl" align="right">
*   یک تبدیل ضمنی (implicit conversion) از `T` به `Nullable<T>` وجود دارد که همیشه موفق است و مقداری را برمی‌گرداند که `HasValue` آن `true` است. این معادل فراخوانی سازنده پارامتردار است.
*   یک تبدیل صریح (explicit conversion) از `Nullable<T>` به `T` وجود دارد که یا مقدار کپسوله‌شده را برمی‌گرداند (اگر `HasValue` برابر `true` باشد) یا یک `InvalidOperationException` پرتاب می‌کند (اگر `HasValue` برابر `false` باشد). این معادل استفاده از خاصیت `Value` است.
</div>

<div dir="rtl" align="right">
وقتی در مورد پشتیبانی زبان صحبت می‌کنم، به موضوع تبدیل‌ها برمی‌گردم. تاکنون، تنها جایی که دیده‌اید CLR نیاز به درک `Nullable<T>` دارد، اجرای محدودیت نوع `struct` است. با این حال، جنبه دیگری از رفتار CLR خاص `nullable`‌ها است: `boxing`.
</div>

<div dir="rtl" align="right">
#### رفتار `boxing`
</div>

<div dir="rtl" align="right">
انواع مقادیر `Nullable` (Nullable value types) هنگام `boxing`، رفتاری متفاوت از انواع مقادیر غیرقابل تهی (non-nullable value types) دارند. هنگامی که یک مقدار از نوع مقدار غیرقابل تهی `box` می‌شود، نتیجه یک ارجاع (reference) به یک شیء از نوعی است که فرم `box` شده نوع اصلی است. به عنوان مثال، فرض کنید این را می‌نویسید:
</div>

```csharp
int x = 5;
object o = x;
```

<div dir="rtl" align="right">
مقدار `o` یک ارجاع به یک شیء از نوع "int `box` شده" است. تفاوت بین `int` `box` شده و `int` معمولاً از طریق C# قابل مشاهده نیست. برای مثال، اگر `o.GetType()` را فراخوانی کنید، `Type` بازگشتی برابر با `typeof(int)` خواهد بود. برخی زبان‌های دیگر (مانند C++/CLI) به توسعه‌دهندگان اجازه می‌دهند بین نوع مقدار اصلی و معادل `box` شده آن تمایز قائل شوند.
</div>

<div dir="rtl" align="right">
با این حال، انواع مقادیر `Nullable` هیچ معادل `box` شده‌ای ندارند. نتیجه `boxing` یک مقدار از نوع `Nullable<T>` به خاصیت `HasValue` بستگی دارد:
*   اگر `HasValue` برابر `false` باشد، نتیجه یک ارجاع `null` است.
*   اگر `HasValue` برابر `true` باشد، نتیجه یک ارجاع به یک شیء از نوع "`T` `box` شده" است.
</div>

<div dir="rtl" align="right">
لیست زیر هر دو نکته را نشان می‌دهد.
</div>

```csharp
Nullable<int> noValue = new Nullable<int>();
object noValueBoxed = noValue;
Console.WriteLine(noValueBoxed == null);

Nullable<int> someValue = new Nullable<int>(5);
object someValueBoxed = someValue;
Console.WriteLine(someValueBoxed.GetType());
```

<div dir="rtl" align="right">
لیست 2.9 اثرات `boxing` مقادیر نوع مقدار `nullable`
</div>

<div dir="rtl" align="right">
*یک مقدار را باکس می‌کند که در آن `HasValue` برابر با `false` است.*
*`True` را چاپ می‌کند: نتیجه `boxing` یک ارجاع `null` است.*
*یک مقدار را باکس می‌کند که در آن `HasValue` برابر با `true` است.*
*`System.Int32` را چاپ می‌کند: نتیجه یک `int` باکس شده است.*
</div>

<div dir="rtl" align="right">
### انواع مقادیر Nullable 43
</div>

<div dir="rtl" align="right">
هنگامی که از این رفتار آگاه هستید، تقریباً همیشه همان چیزی است که می‌خواهید. با این حال، این یک عارضه جانبی عجیب دارد. متد `GetType()` که روی `System.Object` اعلان شده، غیرمجازی (nonvirtual) است و قوانین تا حدی پیچیده در مورد زمان وقوع `boxing` به این معنی است که اگر `GetType()` را روی یک مقدار نوع مقدار (value type) فراخوانی کنید، همیشه ابتدا باید `box` شود. به طور معمول، این کمی ناکارآمد است اما هیچ سردرگمی ایجاد نمی‌کند. با انواع مقادیر `nullable`، یا یک `NullReferenceException` ایجاد می‌کند یا نوع مقدار غیرقابل تهی (non-nullable value type) زیربنایی را برمی‌گرداند. لیست زیر مثال‌هایی از این موارد را نشان می‌دهد.
</div>

```csharp
Nullable<int> noValue = new Nullable<int>();
// Console.WriteLine(noValue.GetType());
Nullable<int> someValue = new Nullable<int>(5);
Console.WriteLine(someValue.GetType());
```

<div dir="rtl" align="right">
*یک `NullReferenceException` ایجاد می‌کند.*
*`System.Int32` را چاپ می‌کند، درست مانند اینکه از `typeof(int)` استفاده کرده باشید.*
</div>

<div dir="rtl" align="right">
شما پشتیبانی چارچوب و پشتیبانی CLR را دیده‌اید، اما زبان C# حتی بیشتر از اینها پیش می‌رود تا کار با انواع مقادیر `nullable` را آسان‌تر کند.
</div>

<div dir="rtl" align="right">
#### 2.2.3 پشتیبانی زبان
</div>

<div dir="rtl" align="right">
ممکن بود C# 2 با کامپایلری عرضه شود که فقط در مورد انواع مقادیر `nullable` هنگام اجرای محدودیت نوع `struct` می‌دانست. این وحشتناک می‌بود، اما در نظر گرفتن حداقل پشتیبانی مورد نیاز برای درک تمام ویژگی‌هایی که برای تناسب انواع مقادیر `nullable` به زبان اضافه شده‌اند، مفید است. بیایید با ساده‌ترین بخش شروع کنیم: ساده‌سازی نام انواع مقادیر `nullable`.
</div>

<div dir="rtl" align="right">
#### پسوند نوع `?`
</div>

<div dir="rtl" align="right">
اگر یک `?` به انتهای نام یک نوع مقدار غیرقابل تهی اضافه کنید، این دقیقاً معادل استفاده از `Nullable<T>` برای همان نوع است. این برای کلیدواژه‌های میانبر برای انواع ساده (`int`، `double` و غیره) و همچنین نام‌های کامل نوع کار می‌کند. به عنوان مثال، این چهار اعلان دقیقاً معادل هستند:
*   `Nullable<int> x;`
*   `Nullable<Int32> x;`
*   `int? x;`
*   `Int32? x;`
</div>

<div dir="rtl" align="right">
شما می‌توانید آنها را هر طور که دوست دارید ترکیب کنید. IL (زبان میانی) تولید شده اصلاً تغییر نخواهد کرد. در عمل، من در همه جا از پسوند `?` استفاده می‌کنم، اما تیم‌های دیگر ممکن است قراردادهای متفاوتی داشته باشند. برای وضوح، من در بقیه متن اینجا از `Nullable<T>` استفاده کرده‌ام، زیرا `?` می‌تواند هنگام استفاده در نثر گیج‌کننده شود، اما در کد به ندرت این موضوع پیش می‌آید.
</div>

<div dir="rtl" align="right">
این ساده‌ترین بهبود زبان است، اما موضوع اجازه دادن به شما برای نوشتن کد مختصر در بقیه این بخش ادامه می‌یابد. پسوند `?` در مورد بیان آسان یک نوع است؛ ویژگی بعدی بر بیان آسان یک مقدار تمرکز دارد.
</div>

<div dir="rtl" align="right">
### 44 فصل 2 C# 2
</div>

<div dir="rtl" align="right">
#### لیترال `null`
</div>

<div dir="rtl" align="right">
در C# 1، عبارت `null` همیشه به یک ارجاع `null` (null reference) اشاره می‌کرد. در C# 2، این معنا به یک مقدار `null` گسترش می‌یابد: یا یک ارجاع `null` یا مقداری از یک نوع مقدار `nullable` که `HasValue` آن `false` است. این می‌تواند برای انتساب‌ها، آرگومان‌های متد، مقایسه‌ها - هر نوع مکانی - استفاده شود. مهم است که بدانید وقتی برای یک نوع مقدار `nullable` استفاده می‌شود، واقعاً نشان‌دهنده مقدار آن نوعی است که `HasValue` آن `false` است، نه یک ارجاع `null`؛ اگر سعی کنید ارجاعات `null` را در مدل ذهنی خود از انواع مقادیر `nullable` بگنجانید، به سرعت گیج‌کننده می‌شود. دو خط زیر معادل هستند:
</div>

```csharp
int? x = new int?();
int? x = null;
```

<div dir="rtl" align="right">
من معمولاً ترجیح می‌دهم از `null` literal به جای فراخوانی صریح سازنده بدون پارامتر استفاده کنم (من خط دوم را به جای اولی می‌نویسم)، اما وقتی صحبت از مقایسه‌ها می‌شود، در مورد دو گزینه بی‌تفاوت هستم. به عنوان مثال، این دو خط معادل هستند:
</div>

```csharp
if (x != null)
if (x.HasValue)
```

<div dir="rtl" align="right">
گمان می‌کنم حتی در مورد اینکه کدام یک را استفاده می‌کنم، ثابت‌قدم نیستم. من از ناسازگاری دفاع نمی‌کنم، اما این حوزه‌ای است که آسیب زیادی نمی‌رساند. همیشه می‌توانید بعداً بدون نگرانی سازگاری، نظر خود را تغییر دهید.
</div>

<div dir="rtl" align="right">
#### تبدیل‌ها
</div>




<div align="right">
شما قبلاً دیده‌اید که `Nullable<T>` یک تبدیل ضمنی (implicit conversion) از `T` به `Nullable<T>` و یک تبدیل صریح (explicit conversion) از `Nullable<T>` به `T` را فراهم می‌کند. زبان این مجموعه از تبدیل‌ها را با اجازه دادن به زنجیره شدن برخی تبدیل‌ها، بیشتر گسترش می‌دهد.
</div>

<div align="right">
جایی که دو نوع مقدار غیرقابل تهی `S` و `T` وجود دارد و یک تبدیل از `S` به `T` وجود دارد (به عنوان مثال، تبدیل از `int` به `decimal`)، تبدیل‌های زیر نیز در دسترس هستند:
</div>


<div dir="rtl" align="right">

*   `Nullable<S>` به `Nullable<T>` (ضمنی یا صریح، بسته به تبدیل اصلی)
*   `S` به `Nullable<T>` (ضمنی یا صریح، بسته به تبدیل اصلی)
*   `Nullable<S>` به `T` (همیشه صریح)

<div>

<div align="right">
اینها به روشی نسبتاً واضح با انتشار مقادیر null و استفاده از تبدیل `S` به `T` در صورت لزوم کار می‌کنند. این فرآیند گسترش یک عملیات برای انتشار مناسب nullها، "lifted" نامیده می‌شود.
</div>

<div align="right">
یک نکته: ممکن است صراحتاً تبدیل‌ها را به انواع قابل تهی و غیرقابل تهی ارائه دهید. LINQ to XML از این به طور مؤثر استفاده می‌کند. به عنوان مثال، تبدیل‌های صریح از `XElement` به هر دو `int` و `Nullable<int>` وجود دارد. بسیاری از عملیات در LINQ to XML اگر از آنها بخواهید عنصری را که وجود ندارد پیدا کنند، یک ارجاع null را برمی‌گردانند، و تبدیل به `Nullable<int>` یک ارجاع null را به یک مقدار null تبدیل می‌کند و null بودن را بدون ایجاد استثنا منتشر می‌کند. با این حال، اگر سعی کنید یک ارجاع `XElement` null را به نوع `int` غیرقابل تهی تبدیل کنید، یک استثنا ایجاد می‌شود. وجود هر دو تبدیل، مدیریت ایمن عناصر اختیاری و الزامی را آسان می‌کند.
</div>


<div align="right">
تبدیل‌ها یک شکل از عملگر (`operator`) هستند که می‌توانند در `C#` داخلی باشند یا توسط کاربر تعریف شوند. سایر عملگرهای تعریف شده بر روی انواع غیرقابل تهی، در همتایان `Nullable` خود رفتار مشابهی دریافت می‌کنند.
</div>

## <div align="right">عملگرهای lifted</div>

<div align="right">
`C#` اجازه می‌دهد تا عملگرهای زیر سربارگذاری (`overloaded`) شوند:
</div>

*   <div align="left">یگانی (`Unary`): `+ ++ - -- ! ~ true false`</div>
*   <div align="left">دوتایی (`Binary`): `+ - * / % & | ^ << >>`</div>
*   <div align="left">برابری (`Equality`): `== !=`</div>
*   <div align="left">رابطه‌ای (`Relational`): `< > <= >=`</div>

<div align="right">
هنگامی که این عملگرها برای یک نوع مقدار غیرقابل تهی `T` سربارگذاری می‌شوند، نوع `Nullable<T>` دارای همان عملگرها با انواع عملوند و نتیجه کمی متفاوت است. اینها "عملگرهای lifted" نامیده می‌شوند، چه عملگرهای از پیش تعریف شده باشند، مانند جمع روی انواع عددی، یا عملگرهای تعریف شده توسط کاربر، مانند افزودن یک `TimeSpan` به یک `DateTime`. چند محدودیت اعمال می‌شود:
</div>

*   <div align="right">عملگرهای `true` و `false` هرگز `lifted` نمی‌شوند. با این حال، آنها در وهله اول فوق‌العاده نادر هستند، بنابراین این ضرر بزرگی نیست.</div>
*   <div align="right">فقط عملگرهایی که انواع مقادیر غیرقابل تهی برای عملوندها دارند، `lifted` می‌شوند.</div>
*   <div align="right">برای عملگرهای یگانی و دوتایی (به غیر از عملگرهای برابری و رابطه‌ای)، نوع بازگشتی عملگر اصلی باید یک نوع مقدار غیرقابل تهی باشد.</div>
*   <div align="right">برای عملگرهای برابری و رابطه‌ای، نوع بازگشتی عملگر اصلی باید `bool` باشد.</div>
*   <div align="right">عملگرهای `&` و `|` روی `Nullable<bool>` رفتارهای جداگانه‌ای تعریف شده‌اند که اکنون آنها را بررسی خواهیم کرد.</div>

<div align="right">
برای همه عملگرها، انواع عملوندها به معادلات `Nullable` خود تبدیل می‌شوند. برای عملگرهای یگانی و دوتایی، نوع بازگشتی نیز `Nullable` می‌شود، و اگر هر یک از عملوندها یک مقدار `Null` باشند، یک مقدار `Null` برگردانده می‌شود. عملگرهای برابری و رابطه‌ای، انواع بازگشتی `بولی` غیرقابل تهی خود را حفظ می‌کنند. برای برابری، دو مقدار `Null` برابر در نظر گرفته می‌شوند، و یک مقدار `Null` و هر مقدار غیر `Null` متفاوت در نظر گرفته می‌شوند. عملگرهای رابطه‌ای همیشه `False` برمی‌گردانند اگر هر یک از عملوندها یک مقدار `Null` باشند. هنگامی که هیچ یک از عملوندها یک مقدار `Null` نباشند، عملگر نوع غیرقابل تهی به روش واضحی فراخوانی می‌شود.
</div>



<div align="right">
تمام این قوانین پیچیده‌تر از آنچه به نظر می‌رسند هستند؛ در اکثر موارد، همه چیز همانطور که احتمالاً انتظار دارید کار می‌کند. دیدن آنچه با چند مثال اتفاق می‌افتد آسان‌تر است، و از آنجا که `int` عملگرهای از پیش تعریف شده زیادی دارد (و اعداد صحیح را می‌توان به راحتی بیان کرد)، نوع نمایشی طبیعی است. جدول 2.1 تعدادی عبارت، امضای عملگر lifted، و نتیجه را نشان می‌دهد. فرض بر این است که متغیرهای `four`، `five` و `nullInt` وجود دارند که هر کدام از نوع `Nullable<int>` هستند و مقادیر واضحی دارند.
</div>

<div align="right">
احتمالاً شگفت‌انگیزترین خط جدول، خط آخر است: اینکه یک مقدار `null` کمتر یا مساوی با یک مقدار `null` دیگر در نظر گرفته نمی‌شود، حتی با وجود اینکه آنها برابر با یکدیگر در نظر گرفته می‌شوند (طبق ردیف هفتم)! این بسیار عجیب است، اما طبق تجربه من، بعید است که در زندگی واقعی مشکلی ایجاد کند. در لیست محدودیت‌های مربوط به lifting عملگر، اشاره کردم که `Nullable<bool>` کمی متفاوت از انواع دیگر عمل می‌کند.
</div>

## <div align="right">منطق NULLABLE</div>

<div align="right">
جداول حقیقت اغلب برای نمایش منطق بولی (`Boolean logic`) با تمام ترکیبات ورودی ممکن و نتیجه استفاده می‌شوند. اگرچه همان رویکرد را می‌توان برای منطق `Nullable<Boolean>` استفاده کرد، ما برای هر ورودی سه مقدار (`true`، `false` و `null`) را برای بررسی داریم به جای فقط `true` و `false`. هیچ عملگر منطقی شرطی (عملگرهای `&&` و `||` که short-circuiting هستند) برای `Nullable<bool>` تعریف نشده است، که زندگی را ساده‌تر می‌کند.
</div>

<div align="right">
فقط عملگرهای منطقی `AND` و `OR` فراگیر (به ترتیب `&` و `|`) رفتار خاصی دارند. سایر عملگرها—نقیض منطقی یگانی (`!`) و `OR` انحصاری (`^`)—از همان قوانین سایر عملگرهای `lifted` پیروی می‌کنند. برای تکمیل، جدول 2.2 جدول حقیقت را برای هر چهار عملگر منطقی معتبر `Nullable<bool>` ارائه می‌دهد. من نتایجی را که اگر قوانین اضافی برای `Nullable<bool>` وجود نداشت متفاوت می‌بود، برجسته کرده‌ام.
</div>

<div align="right">
اگر استدلال در مورد قوانین را آسان‌تر از جستجو در جداول می‌یابید، ایده این است که یک مقدار `null bool?` از جهاتی "شاید" است. اگر تصور کنید که هر ورودی `null` در سمت ورودی جدول به جای یک متغیر است، همیشه در سمت خروجی جدول یک مقدار `null` دریافت خواهید کرد اگر نتیجه به مقدار آن متغیر بستگی داشته باشد. به عنوان مثال، با نگاهی به خط سوم جدول، عبارت `true & y` فقط در صورتی `true` خواهد بود که `y true` باشد، اما عبارت `true | y` همیشه `true` خواهد بود، مهم نیست که مقدار `y` چیست، بنابراین نتایج `nullable` به ترتیب `null` و `true` هستند.
</div>

<div align="right">
هنگام بررسی عملگرهای `lifted` و به ویژه نحوه عملکرد منطق `nullable`، طراحان زبان دو مجموعه رفتار موجود را کمی متناقض می‌دیدند: ارجاعات `null` در `C# 1` و مقادیر `SQL NULL`. در بسیاری از موارد، اینها اصلاً تضادی ندارند؛ `C# 1` هیچ مفهومی از اعمال عملگرهای منطقی بر ارجاعات `null` نداشت، بنابراین هیچ مشکلی در استفاده از نتایج شبه `SQL` که قبلاً ارائه شد وجود نداشت. با این حال، تعاریفی که دیده‌اید ممکن است برخی از توسعه‌دهندگان `SQL` را در مورد مقایسه‌ها شگفت‌زده کند. در `SQL` استاندارد، نتیجه مقایسه دو مقدار (از نظر برابری یا بزرگتر/کوچکتر) همیشه `unknown` است اگر هر یک از مقادیر `NULL` باشد. نتیجه در `C# 2` هرگز `null` نیست، و دو مقدار `null` برابر با یکدیگر در نظر گرفته می‌شوند.
</div>

<div align="right">
جدول 2.1 مثال‌هایی از عملگرهای `lifted` اعمال شده بر اعداد صحیح `nullable`
</div>

<div align="left">

| عبارت              | عملگر lifted           | نتیجه |
| :----------------- | :---------------------- | :---- |
| `nullInt-`         | `int? –(int? x)`        | `null` |
| `five-`            | `int? –(int? x)`        | `-5`  |
| `five + nullInt`   | `int? +(int? x, int? y)` | `null` |
| `five + five`      | `int? +(int? x, int? y)` | `10`  |
| `four & nullInt`   | `int? &(int? x, int? y)` | `null` |
| `four & five`      | `int? &(int? x, int? y)` | `4`   |
| `nullInt == nullInt` | `bool ==(int? x, int? y)` | `true` |
| `five == five`     | `bool ==(int? x, int? y)` | `true` |
| `five == nullInt`  | `bool ==(int? x, int? y)` | `false` |
| `five == four`     | `bool ==(int? x, int? y)` | `false` |
| `four < five`      | `bool <(int? x, int? y)` | `true` |
| `nullInt < five`   | `bool <(int? x, int? y)` | `false` |
| `five < nullInt`   | `bool <(int? x, int? y)` | `false` |
| `nullInt < nullInt` | `bool <(int? x, int? y)` | `false` |
| `nullInt <= nullInt` | `bool <=(int? x, int? y)` | `false` |

</div>

<div align="right">
انواع مقادیر `Nullable` 47
</div>

<div align="right">
جدول 2.2 جدول حقیقت برای عملگرهای `Nullable<bool>`
</div>

<div align="left">

| x      | y      | x & y  | x \| y | x ^ y | !x     |
| :----- | :----- | :----- | :----- | :---- | :----- |
| `true` | `true` | `true` | `true` | `false` | `false` |
| `true` | `false` | `false` | `true` | `true` | `false` |
| `true` | `null` | `null` | `true` | `null` | `false` |
| `false` | `true` | `false` | `true` | `true` | `true` |
| `false` | `false` | `false` | `false` | `false` | `true` |
| `false` | `null` | `false` | `null` | `null` | `true` |
| `null` | `true` | `null` | `true` | `null` | `null` |
| `null` | `false` | `false` | `null` | `null` | `null` |
| `null` | `null` | `null` | `null` | `null` | `null` |

</div>

<div align="right">
نتایج عملگرهای `lifted` خاص `C#`
</div>

<div align="right">
عملگرهای `lifted` و تبدیل‌ها، به همراه منطق `Nullable<bool>` که در این بخش توضیح داده شد، همگی توسط کامپایلر `C#` ارائه می‌شوند و نه توسط `CLR` یا خود چارچوب. اگر از `ildasm` روی کدی استفاده کنید که هر یک از این عملگرهای `nullable` را ارزیابی می‌کند، متوجه خواهید شد که کامپایلر تمام `IL` مناسب را برای آزمایش مقادیر `null` ایجاد کرده و با آنها بر اساس آن برخورد کرده است.
</div>


<div align="right">
48 فصل 2 `C# 2`
یک عملگر آشنای دیگر اکنون با انواع مقادیر `nullable` در دسترس است و به احتمال زیاد همانطور که انتظار دارید رفتار می‌کند، اگر دانش موجود خود را از ارجاعات `null` در نظر بگیرید و فقط آن را به صورت مقادیر `null` تنظیم کنید.
</div>

## <div align="right">عملگر `as` و انواع مقادیر `nullable`</div>

<div align="right">
قبل از `C# 2`، عملگر `as` فقط برای انواع مرجع در دسترس بود. از `C# 2`، اکنون می‌توان آن را به انواع مقادیر `nullable` نیز اعمال کرد. نتیجه یک مقدار از آن نوع `nullable` است: مقدار `null` اگر ارجاع اصلی از نوع اشتباه یا `null` بود یا در غیر این صورت یک مقدار معنی‌دار. در اینجا یک مثال کوتاه آورده شده است:
</div>


<div dir="ltr" align="left">


```csharp
static void PrintValueAsInt32(object o)
{
    int? nullable = o as int?;
    Console.WriteLine(nullable.HasValue ?
                      nullable.Value.ToString() : "null");
}
// ...
PrintValueAsInt32(5);
PrintValueAsInt32("some string");
```
</div>

<div align="right">
این به شما امکان می‌دهد تا با خیال راحت از یک ارجاع دلخواه به یک مقدار در یک مرحله تبدیل کنید، اگرچه معمولاً بعداً بررسی می‌کنید که آیا نتیجه `null` است یا خیر. در `C# 1`، باید از عملگر `is` و سپس یک `cast` استفاده می‌کردید، که بی‌ظرافت است؛ اساساً از `CLR` می‌خواهید همان بررسی نوع را دو بار انجام دهد.
</div>

<div align="right">
**نکته:** استفاده از عملگر `as` با انواع `nullable` به طرز شگفت‌آوری کند است. در بیشتر کدها، این احتمالاً مهم نیست (برای مثال، در مقایسه با هر `I/O` کند نخواهد بود)، اما در تمام ترکیب‌های چارچوب و کامپایلر که امتحان کرده‌ام، کندتر از `is` و سپس یک `cast` است.
</div>

<div align="right">
`C# 7` راه‌حل بهتری را برای اکثر مواردی که من از عملگر `as` با انواع مقادیر `nullable` با استفاده از تطبیق الگو (`pattern matching`) (توصیف شده در فصل 12) استفاده کرده‌ام، ارائه می‌دهد. با این حال، اگر نوع نتیجه مورد نظر شما واقعاً یک `Nullable<T>` باشد، عملگر `as` مفید است. در نهایت، `C# 2` یک عملگر کاملاً جدید را به طور خاص برای مدیریت زیبا مقادیر `null` معرفی کرد.
</div>

## <div align="right">عملگر `null-coalescing ??`</div>

<div align="right">
کاملاً معمول است که بخواهیم از انواع مقادیر `nullable` - یا حتی انواع مرجع - استفاده کنیم و نوعی مقدار پیش‌فرض را ارائه دهیم اگر یک عبارت خاص به `null` ارزیابی شود. `C# 2` عملگر `??` را معرفی کرد که به عنوان عملگر `null-coalescing` نیز شناخته می‌شود، دقیقاً برای همین منظور.
</div>

<div align="right">
(ادامه)
زبان‌های مختلف می‌توانند در این مسائل متفاوت رفتار کنند، و این قطعاً چیزی است که باید به آن توجه کنید اگر نیاز به پورت کد بین زبان‌های مختلف مبتنی بر `.NET` دارید. به عنوان مثال، `VB` عملگرهای `lifted` را بسیار شبیه `SQL` رفتار می‌کند، بنابراین نتیجه `x < y` اگر `x` یا `y Nothing` باشد، `Nothing` است.
</div>

```
چاپ 5
چاپ null
```

<div align="right">
ایجاد دلیگیت ساده‌شده 49
`??` یک عملگر دوتایی (`binary operator`) است که با طی مراحل زیر (به طور تقریبی) عبارتی مانند `first ?? second` را ارزیابی می‌کند:


1.  <div align="right">`first` را ارزیابی کنید.</div>
2.  <div align="right">اگر نتیجه غیر `null` بود، آن نتیجه کل عبارت است.</div>
3.  <div align="right">در غیر این صورت، `second` را ارزیابی کنید و از آن به عنوان نتیجه کل عبارت استفاده کنید.</div>

</div>

<div align="right">
می‌گویم تقریبی، زیرا قوانین رسمی در مشخصات باید با موقعیت‌هایی که شامل تبدیل بین انواع `first` و `second` هستند، سر و کار داشته باشند. اینها در اکثر کاربردهای عملگر مهم نیستند و من قصد ندارم به آنها بپردازم. اگر به آنها نیاز دارید، پیدا کردنشان در مشخصات آسان است.
</div>

<div align="right">
یک جنبه از آن قوانین که ارزش برجسته کردن دارد. اگر نوع عملوند اول یک نوع مقدار `nullable` باشد و نوع عملوند دوم نوع زیربنایی عملوند اول باشد، نوع کل عبارت آن نوع زیربنایی (غیر `nullable`) خواهد بود. به عنوان مثال، این کد کاملاً معتبر است:
</div>

<div dir="ltr" align="left">


```csharp
int? a = 5;
int b = 10;
int c = a ?? b;
```
</div>

<div align="right">
توجه داشته باشید که شما مستقیماً به `c` مقداردهی می‌کنید، حتی با وجود اینکه نوع آن `int` غیر `nullable` است. شما این کار را فقط به این دلیل می‌توانید انجام دهید که `b` غیر `nullable` است، بنابراین می‌دانید که نتیجه کلی نمی‌تواند `null` باشد. عملگر `??` به خوبی با خودش ترکیب می‌شود؛ عبارتی مانند `x ?? y ?? z` فقط `y` را ارزیابی می‌کند اگر `x` به `null` ارزیابی شود و فقط `z` را ارزیابی می‌کند اگر هر دو `x` و `y` به `null` ارزیابی شوند.
</div>

<div align="right">
مقادیر `null` حتی آسان‌تر می‌شوند - و به احتمال زیاد به عنوان نتایج عبارت - در `C# 6` با عملگر شرطی `?. null`، همانطور که در بخش `10.3` خواهید دید. ترکیب `?.` و `??` می‌تواند راه قدرتمندی برای مدیریت `null`های احتمالی در نقاط مختلف اجرا باشد. مانند همه تکنیک‌ها، این بهتر است با اعتدال استفاده شود. اگر متوجه شدید که خوانایی کد شما رو به کاهش است، ممکن است بخواهید استفاده از چندین دستور را برای جلوگیری از تلاش برای انجام بیش از حد در یک مرحله در نظر بگیرید.
</div>



<div align="right">
این از انواع مقادیر `nullable` در `C# 2`. ما اکنون دو ویژگی مهم `C# 2` را پوشش داده‌ایم، اما چند ویژگی نسبتاً بزرگ دیگر برای صحبت داریم، همراه با انبوهی از ویژگی‌های کوچکتر. بعدی دلیگیت‌ها هستند.
</div>

## <div align="right">2.3 ایجاد دلیگیت ساده‌شده</div>

<div align="right">
هدف اصلی دلیگیت‌ها از زمانی که برای اولین بار معرفی شدند تغییر نکرده است: کپسوله‌سازی یک قطعه کد به گونه‌ای که بتوان آن را به اطراف منتقل کرد و در صورت لزوم به صورت `type-safe` (ایمن از نظر نوع) از نظر نوع بازگشتی و پارامترها اجرا کرد. در گذشته `C# 1`، این تقریباً همیشه برای مدیریت رویدادها (`event handling`) یا شروع رشته‌ها (`starting threads`) استفاده می‌شد. این عمدتاً هنوز هم در زمان معرفی `C# 2` در سال 2005 صادق بود. فقط در سال 2008 بود که `LINQ` به توسعه‌دهندگان `C#` کمک کرد تا با ایده انتقال یک تابع به دلایل مختلف احساس راحتی کنند.
</div>

<div align="right">
`C# 2` سه روش جدید برای ایجاد نمونه‌های دلیگیت و همچنین قابلیت اعلان دلیگیت‌های جنریک مانند `EventHandler<TEventArgs>` و `Action<T>` را به ارمغان آورد. ما با تبدیل‌های گروه متد (`method group conversions`) شروع خواهیم کرد.
</div>

<div align="right">
50 فصل 2 `C# 2`
</div>

### <div align="right">2.3.1 تبدیل گروه متد</div>

<div align="right">
یک گروه متد به یک یا چند متد با نام یکسان اشاره دارد. هر توسعه‌دهنده `C#` برای همیشه از آنها استفاده کرده است بدون اینکه لزوماً به آن فکر کند، زیرا هر فراخوانی متد از یکی استفاده می‌کند. به عنوان مثال، این کد بی‌اهمیت را در نظر بگیرید:
</div>

<div align="left">

```csharp
Console.WriteLine("hello");
```
</div>

<div align="right">
عبارت `Console.WriteLine` یک گروه متد است. کامپایلر سپس به آرگومان‌ها نگاه می‌کند تا بفهمد کدام یک از سربارگذاری‌ها (`overloads`) در آن گروه متد باید فراخوانی شود. به غیر از فراخوانی‌های متد، `C# 1` از گروه‌های متد در عبارات ایجاد دلیگیت به عنوان تنها راهی که زبان برای ایجاد نمونه دلیگیت فراهم می‌کرد، استفاده می‌کرد. به عنوان مثال، فرض کنید متدی مانند این دارید:
</div>

<div align="left">

```csharp
private void HandleButtonClick(object sender, EventArgs e)
```
</div>

<div align="right">

سپس می‌توانید یک نمونه `EventHandler` را به این صورت ایجاد کنید:
</div>

<div align="left">

```csharp
EventHandler handler = new EventHandler(HandleButtonClick);
```
</div>

<div align="right">

`C# 2` تبدیل‌های گروه متد را به عنوان نوعی میانبر معرفی کرد: یک گروه متد به طور ضمنی قابل تبدیل به هر نوع دلیگیت با امضای سازگار با یکی از سربارگذاری‌ها است. شما مفهوم سازگاری را در بخش 2.3.3 بیشتر بررسی خواهید کرد، اما در حال حاضر به متدهایی نگاه خواهیم کرد که دقیقاً با امضای دلیگیتی که می‌خواهید به آن تبدیل کنید مطابقت دارند.
</div>

<div align="right">

در مورد کد `EventHandler` قبلی ما، `C# 2` به شما اجازه می‌دهد ایجاد دلیگیت را به این صورت ساده کنید:
</div>

<div align="left">

```csharp
EventHandler handler = HandleButtonClick;
```
</div>

<div align="right">

این برای اشتراک و حذف رویداد نیز کار می‌کند:
</div>

<div align="left">

```csharp
button.Click += HandleButtonClick;
```
</div>

<div align="right">
همان کد برای عبارت ایجاد دلیگیت تولید می‌شود، اما بسیار مختصرتر است. این روزها، من به ندرت عبارات ایجاد دلیگیت را در کدهای اصطلاحی می‌بینم.
</div>

<div align="right">
تبدیل‌های گروه متد چند کاراکتر را هنگام ایجاد نمونه دلیگیت ذخیره می‌کنند، اما متدهای ناشناس (`anonymous methods`) بسیار بیشتر به دست می‌آورند.
</div>

### <div align="right">2.3.2 متدهای ناشناس</div>

<div align="right">
شما ممکن است به طور منطقی انتظار جزئیات زیادی در مورد متدهای ناشناس در اینجا داشته باشید. من بیشتر آن اطلاعات را برای جانشین متدهای ناشناس: عبارات لامبدا (`lambda expressions`) ذخیره خواهم کرد. آنها در `C# 3` معرفی شدند، و من انتظار دارم که اگر قبل از متدهای ناشناس وجود داشتند، دومی هرگز معرفی نمی‌شد.
</div>

<div align="right">
6 برای ارجاع، `EventHandler` دارای امضای `public delegate void EventHandler(object sender, EventArgs e)` است.
</div>

<div align="right">
ایجاد دلیگیت ساده‌شده 51
حتی با این وجود، معرفی آنها در `C# 2` باعث شد من به دلیگیت‌ها به روشی کاملاً متفاوت فکر کنم. متدهای ناشناس به شما امکان می‌دهند یک نمونه دلیگیت را بدون داشتن یک متد واقعی برای ارجاع، تنها با نوشتن مقداری کد درون خطی در هر کجا که می‌خواهید نمونه را ایجاد کنید، ایجاد کنید. فقط از کلمه کلیدی `delegate` استفاده می‌کنید، اختیاری برخی پارامترها را شامل می‌شوید، و سپس مقداری کد را در آکولادها می‌نویسید. به عنوان مثال، اگر می‌خواستید یک رویدادگیرنده (`event handler`) که فقط در هنگام اجرا به کنسول `log` می‌کرد، می‌توانید این کار را به سادگی انجام دهید:
</div>

<div align="left">

```csharp
EventHandler handler = delegate
{
    Console.WriteLine("Event raised");
};
```
</div>

<div align="right">

این فوراً `Console.WriteLine` را فراخوانی نمی‌کند؛ بلکه یک دلیگیت ایجاد می‌کند که هنگام فراخوانی، `Console.WriteLine` را فراخوانی می‌کند. برای دیدن نوع فرستنده (`sender`) و آرگومان‌های رویداد، به پارامترهای مناسب نیاز دارید:
</div>

<div align="left">

```csharp
EventHandler handler = delegate(object sender, EventArgs args)
{
    Console.WriteLine("Event raised. sender={0}; args={1}",
                      sender.GetType(), args.GetType());
};
```
</div>

<div align="right">
قدرت واقعی زمانی حاصل می‌شود که یک متد ناشناس را به عنوان یک `closure` استفاده کنید. یک `closure` قادر است به تمام متغیرهایی که در نقطه اعلان آن در حوزه (`scope`) هستند دسترسی داشته باشد، حتی اگر آن متغیرها معمولاً هنگام اجرای دلیگیت دیگر در دسترس نباشند. شما `closures` را با جزئیات بسیار بیشتری (از جمله نحوه برخورد کامپایلر با آنها) هنگام بررسی عبارات لامبدا بررسی خواهید کرد. در حال حاضر، در اینجا یک مثال کوتاه آورده شده است؛ این یک متد `AddClickLogger` است که یک رویدادگیرنده `Click` را به هر کنترلی با یک پیام سفارشی که به `AddClickLogger` منتقل می‌شود، اضافه می‌کند:
</div>

<div align="left">

```csharp
void AddClickLogger(Control control, string message)
{
    control.Click += delegate
    {
        Console.WriteLine("Control clicked: {0}", message);
    }
}
```
</div>

<div align="right">

در اینجا متغیر `message` یک پارامتر برای متد است، اما توسط متد ناشناس `capture` می‌شود. متد `AddClickLogger` خود رویدادگیرنده را اجرا نمی‌کند؛ فقط آن را به عنوان یک رویدادگیرنده برای رویداد `Click` اضافه می‌کند. تا زمانی که کد در متد ناشناس اجرا شود، `AddClickLogger` بازگشته است. چگونه پارامتر هنوز وجود دارد؟ به طور خلاصه، کامپایلر همه چیز را برای شما مدیریت می‌کند تا از نوشتن کد خسته‌کننده جلوگیری کند. بخش `3.5.2` جزئیات بیشتری را هنگام بررسی `capture` کردن متغیرها در عبارات لامبدا ارائه می‌دهد. در اینجا هیچ چیز خاصی در مورد `EventHandler` وجود ندارد؛ فقط یک نوع دلیگیت شناخته شده است که همیشه بخشی از چارچوب بوده است. برای بخش نهایی سفر سریع ما به بهبودهای دلیگیت `C# 2`، بیایید به ایده سازگاری برگردیم، که هنگام صحبت در مورد تبدیل‌های گروه متد به آن اشاره کردم.
</div>

<div align="right">
7 حداقل در کد منبع شما. متد هنوز در `IL` وجود دارد.
</div>


<div align="right">
52 فصل 2 `C# 2`
</div>

### <div align="right">2.3.3 سازگاری دلیگیت</div>

<div align="right">
در `C# 1`، برای ایجاد یک نمونه دلیگیت (`delegate instance`) به یک متد با امضای دقیقاً یکسان (شامل نوع بازگشتی و انواع پارامترها و همچنین تغییردهنده‌های `ref/out`) نیاز داشتید. به عنوان مثال، فرض کنید این اعلان دلیگیت و متد را داشتید:
</div>

<div align="left">

```csharp
public delegate void Printer(string message);
public void PrintAnything(object obj)
{
    Console.WriteLine(obj);
}
```
</div>

<div align="right">
اکنون تصور کنید می‌خواستید یک نمونه از `Printer` را برای بسته‌بندی مؤثر متد `PrintAnything` ایجاد کنید. به نظر می‌رسد که باید مشکلی نباشد؛ یک `Printer` همیشه یک ارجاع `string` دریافت خواهد کرد، و آن از طریق یک تبدیل هویت (`identity conversion`) قابل تبدیل به یک ارجاع `object` است. با این حال، `C# 1` این را اجازه نمی‌داد، زیرا انواع پارامترها مطابقت نداشتند.
</div>

<div align="right">
`C# 2` این را برای عبارات ایجاد دلیگیت و برای تبدیل‌های گروه متد (`method group conversions`) اجازه می‌دهد:
</div>

<div align="left">

```csharp
Printer p1 = new Printer(PrintAnything);
Printer p2 = PrintAnything;
```
</div>

<div align="right">
علاوه بر این، می‌توانید یک دلیگیت برای بسته‌بندی دلیگیت دیگری با امضای سازگار ایجاد کنید. فرض کنید یک نوع دلیگیت دوم داشتید که به طور تصادفی با متد `PrintAnything` مطابقت داشت:
</div>

<div align="left">

```csharp
public delegate void GeneralPrinter(object obj);
```
</div>

<div align="right">

اگر از قبل یک `GeneralPrinter` دارید، می‌توانید یک `Printer` از آن ایجاد کنید:
</div>

<div align="left">

```csharp
GeneralPrinter generalPrinter = ...;
Printer printer = new Printer(generalPrinter);
```
</div>

<div align="right">
<div align="right">هر راهی که می‌توانید یک دلیگیت `GeneralPrinter` ایجاد کنید.</div>
<div align="right">یک `Printer` برای بسته‌بندی `GeneralPrinter` ایجاد می‌کند.</div>
</div>

<div align="right">
کامپایلر به شما اجازه می‌دهد این کار را انجام دهید زیرا ایمن است؛ هر آرگومانی که می‌تواند به یک `Printer` منتقل شود، به طور ایمن می‌تواند به یک `GeneralPrinter` منتقل شود. کامپایلر از انجام همین کار در جهت دیگر برای انواع بازگشتی نیز خوشحال است، همانطور که در مثال زیر نشان داده شده است:
</div>

<div align="left">

```csharp
public delegate object ObjectProvider();
public delegate string StringProvider();
StringProvider stringProvider = ...;
ObjectProvider objectProvider =
new ObjectProvider(stringProvider);
```
</div>

<div align="right">
<div align="right">دلیگیت‌های بدون پارامتر که مقادیر را برمی‌گردانند.</div>
<div align="right">هر راهی که می‌توانید یک `StringProvider` ایجاد کنید.</div>
<div align="right">یک `ObjectProvider` برای بسته‌بندی `StringProvider` ایجاد می‌کند.</div>
</div>

<div align="right">
ایتریتورها 53
باز هم، این ایمن است زیرا هر مقداری که `StringProvider` می‌تواند بازگرداند، قطعاً برای بازگشت از یک `ObjectProvider` مناسب خواهد بود.
</div>

<div align="right">
با این حال، همیشه آنطور که می‌خواهید کار نمی‌کند. سازگاری بین پارامترهای مختلف یا انواع بازگشتی باید از طریق یک تبدیل هویت (`identity conversion`) باشد که نمایش مقدار را در زمان اجرا تغییر ندهد. به عنوان مثال، این کد کامپایل نمی‌شود:
</div>

<div align="left">

```csharp
public delegate void Int32Printer(int x);
public delegate void Int64Printer(long x);
Int64Printer int64Printer = ...;
Int32Printer int32Printer =
new Int32Printer(int64Printer);
```
</div>

<div align="right">
امضای دو دلیگیت در اینجا سازگار نیستند؛ اگرچه یک تبدیل ضمنی (`implicit conversion`) از `int` به `long` وجود دارد، اما این یک تبدیل هویت نیست. ممکن است استدلال کنید که کامپایلر می‌توانست به طور بی‌صدا متدی ایجاد کند که تبدیل را برای شما انجام دهد، اما این کار را نمی‌کند. به نوعی، این مفید است، زیرا این رفتار با ویژگی واریانس جنریک (`generic variance`) که در فصل 4 خواهید دید، مطابقت دارد.
</div>



<div align="right">
مهم است که درک کنیم اگرچه این ویژگی کمی شبیه واریانس جنریک به نظر می‌رسد، اما آنها ویژگی‌های متفاوتی هستند. گذشته از هر چیز دیگری، این بسته‌بندی واقعاً یک نمونه جدید از دلیگیت ایجاد می‌کند، نه اینکه فقط دلیگیت موجود را به عنوان نمونه‌ای از نوع دیگری در نظر بگیرد. وقتی ویژگی را به طور کامل بررسی می‌کنیم، به جزئیات بیشتری خواهم پرداخت، اما می‌خواستم هر چه زودتر برجسته کنم که آنها یکسان نیستند.
</div>

<div align="right">
این از دلیگیت‌ها در `C# 2`. تبدیل‌های گروه متد هنوز به طور گسترده‌ای استفاده می‌شوند، و اغلب جنبه سازگاری بدون اینکه کسی به آن فکر کند، استفاده خواهد شد. متدهای ناشناس امروزه چندان دیده نمی‌شوند، زیرا عبارات لامبدا تقریباً هر کاری که متدهای ناشناس می‌توانند انجام دهند، انجام می‌دهند، اما من هنوز آنها را با علاقه به عنوان اولین تجربه من از قدرت `closures` می‌بینم. در مورد یک ویژگی که منجر به دیگری شد، بیایید به پیشرو همزمانی `C# 5`: بلوک‌های `iterator` نگاه کنیم.
</div>

## <div align="right">2.4 ایتریتورها</div>

<div align="right">
نسبتاً تعداد کمی از رابط‌ها در `C#` 2 پشتیبانی زبانی خاصی دارند. `IDisposable` از طریق دستور `using` پشتیبانی می‌شود، و زبان تضمین‌هایی در مورد رابط‌هایی که آرایه‌ها پیاده‌سازی می‌کنند می‌دهد، اما به غیر از آن، تنها رابط‌های قابل شمارش (`enumerable`) پشتیبانی مستقیم دارند. `IEnumerable` همیشه از نظر مصرف در قالب دستور `foreach` پشتیبانی شده است، و `C# 2` آن را به همتای عمومی جدید خود در `NET 2`، `IEnumerable<T>`، به روشی نسبتاً واضح گسترش داد.
</div>

<div align="right">
رابط‌های قابل شمارش، دنباله‌هایی از آیتم‌ها را نشان می‌دهند، و اگرچه مصرف آنها بسیار رایج است، اما کاملاً منطقی است که بخواهیم یک دنباله تولید کنیم. پیاده‌سازی دستی رابط‌های عمومی یا غیرعمومی می‌تواند خسته‌کننده و مستعد خطا باشد، بنابراین `C# 2` ویژگی جدیدی به نام ایتریتورها (`iterators`) را برای ساده‌تر کردن آن معرفی کرد.
</div>

<div align="right">

<div align="left">دلیگیت‌هایی که اعداد صحیح 32 و 64 بیتی را می‌پذیرند.</div>
<div align="left">هر راهی که می‌توانید یک `Int64Printer` ایجاد کنید.</div>
<div align="left">خطا! نمی‌توان `Int64Printer` را در یک `Int32Printer` قرار داد.</div>
</div>

<div align="right">
54 فصل 2 `C# 2`
</div>

### <div align="right">2.4.1 معرفی ایتریتورها</div>

<div align="right">
یک ایتریتور، یک متد یا ویژگی است که با یک بلوک ایتریتور (`iterator block`) پیاده‌سازی شده است، که به نوبه خود فقط یک بلوک کد با استفاده از دستورات `yield return` یا `yield break` است. بلوک‌های ایتریتور فقط برای پیاده‌سازی متدها یا ویژگی‌ها با یکی از انواع بازگشتی زیر قابل استفاده هستند:
</div>

*   <div align="left">`IEnumerable`</div>
*   <div align="left">`IEnumerable<T>` (که در آن `T` می‌تواند یک پارامتر نوع یا یک نوع معمولی باشد)</div>
*   <div align="left">`IEnumerator`</div>
*   <div align="left">`IEnumerator<T>` (که در آن `T` می‌تواند یک پارامتر نوع یا یک نوع معمولی باشد)</div>

<div align="right">
هر ایتریتور دارای یک نوع `yield` بر اساس نوع بازگشتی خود است. اگر نوع بازگشتی یکی از رابط‌های غیر عمومی باشد، نوع `yield` از نوع `object` است. در غیر این صورت، آرگومان نوعی است که به رابط ارائه شده است. به عنوان مثال، نوع `yield` یک متد که `IEnumerator<string>` را برمی‌گرداند، `string` است.
</div>

<div align="right">
دستورات `yield return` مقادیر را برای دنباله بازگشتی فراهم می‌کنند، و یک دستور `yield break` یک دنباله را خاتمه می‌دهد. ساختارهای مشابه، که گاهی اوقات "`generators`" نامیده می‌شوند، در برخی زبان‌های دیگر مانند پایتون وجود دارند.
</div>

<div align="right">
لیست زیر یک متد ایتریتور ساده را نشان می‌دهد که می‌توانید آن را بیشتر تجزیه و تحلیل کنید. من دستورات `yield return` را در متد برجسته کرده‌ام.
</div>

<div align="left">

```csharp
static IEnumerable<int> CreateSimpleIterator()
{
    yield return 10;
    for (int i = 0; i < 3; i++)
    {
        yield return i;
    }
    yield return 20;
}
```
</div>

<div align="right">
با وجود این متد، می‌توانید متد را فراخوانی کرده و روی نتایج با یک حلقه `foreach` معمولی تکرار کنید:
</div>

<div align="left">

```csharp
foreach (int value in CreateSimpleIterator())
{
    Console.WriteLine(value);
}
```
</div>

<div align="right">
این حلقه خروجی زیر را چاپ خواهد کرد:
</div>

<div align="left">


```
10
0
1
2
20
```
</div>

<div align="right">
لیست 2.11 یک ایتریتور ساده که اعداد صحیح را تولید می‌کند.
</div>

<div align="right">
ایتریتورها 55
این چندان هیجان‌انگیز نیست. می‌توانید متد را تغییر دهید تا یک `List<int>` ایجاد کند، هر دستور `yield return` را با فراخوانی `Add()` جایگزین کنید، و سپس لیست را در انتهای متد برگردانید. خروجی حلقه دقیقاً یکسان خواهد بود، اما اصلاً به همان شیوه اجرا نخواهد شد. تفاوت بزرگ این است که ایتریتورها به صورت `lazy` (تنبل) اجرا می‌شوند.
</div>

### <div align="right">2.4.2 اجرای تنبل (`Lazy execution`)</div>

<div align="right">

اجرای تنبل، یا ارزیابی تنبل، به عنوان بخشی از حساب لامبدا در دهه 1930 ابداع شد. ایده اصلی آن ساده است: کد را فقط زمانی اجرا کنید که به مقداری که محاسبه خواهد کرد نیاز دارید. استفاده‌های آن فراتر از ایتریتورها است، اما در حال حاضر فقط به آنها نیاز داریم.
</div>

<div align="right">

برای توضیح نحوه اجرای کد، لیست زیر حلقه `foreach` را به کدی تقریباً معادل آن بسط می‌دهد که به جای آن از یک حلقه `while` استفاده می‌کند. من هنوز از شکر سینتکسی دستور `using` استفاده کرده‌ام که به طور خودکار `Dispose()` را فراخوانی می‌کند، فقط برای سادگی.
</div>

<div align="left">

```csharp
IEnumerable<int> enumerable = CreateSimpleIterator();
using (IEnumerator<int> enumerator =
       enumerable.GetEnumerator())
{
    while (enumerator.MoveNext())
    {
        int value = enumerator.Current;
        Console.WriteLine(value);
    }
}
```
</div>

<div align="right">

اگر قبلاً هرگز به زوج رابط‌های `IEnumerable/IEnumerator` (و معادلات عمومی آنها) نگاه نکرده‌اید، اکنون زمان خوبی برای اطمینان از درک تفاوت بین آنها است. `IEnumerable` یک دنباله است که می‌توان روی آن تکرار کرد، در حالی که `IEnumerator` مانند یک مکان‌نما در یک دنباله است. چندین نمونه `IEnumerator` احتمالاً می‌توانند روی یک `IEnumerable` بدون تغییر حالت آن تکرار کنند. این را با `IEnumerator` مقایسه کنید، که به طور طبیعی دارای حالت `mutable` است: هر بار که `MoveNext()` را فراخوانی می‌کنید، از آن می‌خواهید مکان‌نما را به عنصر بعدی دنباله‌ای که روی آن تکرار می‌شود، منتقل کند.
</div>

<div align="right">
اگر این خیلی منطقی نبود، ممکن است بخواهید یک `IEnumerable` را به عنوان یک کتاب و یک `IEnumerator` را به عنوان یک نشانک در نظر بگیرید. در هر زمان می‌توان چندین نشانک در یک کتاب وجود داشته باشد. حرکت دادن یک نشانک به صفحه بعدی کتاب یا نشانک‌های دیگر را تغییر نمی‌دهد، اما حالت آن نشانک را تغییر می‌دهد: موقعیت آن در کتاب. متد `IEnumerable.GetEnumerator()` نوعی بوت‌استرپینگ است: از دنباله می‌خواهد یک `IEnumerator` ایجاد کند که برای تکرار روی آن دنباله تنظیم شده است، دقیقاً مانند قرار دادن یک نشانک جدید در ابتدای یک کتاب.
</div>

<div align="right">
لیست 2.12 بسط یک حلقه `foreach`
<div align="left">متد ایتریتور را فراخوانی می‌کند.</div>
<div align="left">یک `IEnumerator<T>` را از یک `IEnumerable<T>` دریافت می‌کند.</div>
<div align="left">به مقدار بعدی حرکت می‌کند، در صورت وجود.</div>
<div align="left">مقدار فعلی را دریافت می‌کند.</div>
</div>



<div align="right">

56 فصل 2 `C# 2`
پس از داشتن یک `IEnumerator`، به طور مکرر `MoveNext()` را فراخوانی می‌کنید؛ اگر `true` برگرداند، به این معنی است که به مقدار دیگری منتقل شده‌اید که می‌توانید با خاصیت `Current` به آن دسترسی پیدا کنید. اگر `MoveNext()` مقدار `false` را برگرداند، به انتهای دنباله رسیده‌اید.
</div>

<div align="right">

این چه ربطی به ارزیابی `lazy` دارد؟ خوب، اکنون که دقیقاً می‌دانید کد استفاده کننده از ایتریتور چه چیزی را فراخوانی خواهد کرد، می‌توانید بررسی کنید که چه زمانی بدنه متد شروع به اجرا می‌کند. فقط به عنوان یادآوری، این متد از لیست 2.11 است:
</div>

<div align="left">

```csharp
static IEnumerable<int> CreateSimpleIterator()
{
    yield return 10;
    for (int i = 0; i < 3; i++)
    {
        yield return i;
    }
    yield return 20;
}
```
</div>

<div align="right">

هنگامی که `CreateSimpleIterator()` فراخوانی می‌شود، هیچ یک از بدنه متد اجرا نمی‌شود.
</div>

<div align="right">
اگر یک `breakpoint` روی خط اول (`yield return 10;`) قرار دهید و کد را گام به گام (`step through`) اجرا کنید، هنگامی که متد را فراخوانی می‌کنید، به `breakpoint` نمی‌رسید. همچنین هنگامی که `GetEnumerator()` را فراخوانی می‌کنید، به `breakpoint` نمی‌رسید. بدنه متد تنها زمانی شروع به اجرا می‌کند که `MoveNext()` فراخوانی شود. اما سپس چه اتفاقی می‌افتد؟
</div>

### <div align="right">2.4.3 ارزیابی دستورات `yield`</div>

<div align="right">

حتی زمانی که متد شروع به اجرا می‌کند، تنها تا جایی که لازم است پیش می‌رود. در یکی از موارد زیر، اجرا متوقف می‌شود:
</div>

*   <div align="right">یک استثنا پرتاب می‌شود.</div>
*   <div align="right">به انتهای متد می‌رسد.</div>
*   <div align="right">به یک دستور `yield break` می‌رسد.</div>
*   <div align="right">عملوند یک دستور `yield return` را ارزیابی کرده است، بنابراین آماده تولید مقدار است.</div>

<div align="right">

اگر یک استثنا پرتاب شود، آن استثنا به طور معمول منتشر می‌شود. اگر به انتهای متد برسد یا به یک دستور `yield break` برخورد کند، متد `MoveNext()` مقدار `false` را برمی‌گرداند تا نشان دهد به انتهای دنباله رسیده‌اید. اگر به یک دستور `yield return` برسید، خاصیت `Current` به مقداری که تولید می‌کنید تنظیم می‌شود و `MoveNext()` مقدار `true` را برمی‌گرداند.
</div>

<div align="right">

**نکته:** برای روشن شدن پاراگراف بالا، استثنا به طور معمول منتشر می‌شود، با فرض اینکه شما در حال اجرای کد ایتریتور هستید. فراموش نکنید که تا زمانی که کد فراخوانی روی دنباله بازگشتی تکرار نشود، اجرای کد ایتریتور شروع نمی‌شود. این فراخوانی `MoveNext()` است که استثنا را پرتاب می‌کند، نه فراخوانی اولیه به متد ایتریتور.
</div>

<div align="right">

در مثال ساده ما، به محض اینکه `MoveNext()` شروع به تکرار می‌کند، به دستور `yield return 10;` می‌رسد، `Current` را به 10 تنظیم می‌کند و سپس `true` را برمی‌گرداند.
</div>

<div align="right">

ایتریتورها 57
این همه برای اولین فراخوانی `MoveNext()` ساده به نظر می‌رسد، اما برای فراخوانی‌های بعدی چطور؟ نمی‌توانید از ابتدا شروع کنید؛ در غیر این صورت، دنباله 10 بار بی‌نهایت تکرار می‌شود. در عوض، وقتی `MoveNext()` برمی‌گردد، انگار متد متوقف شده است. کد تولید شده نقطه‌ای را که در متد رسیده‌اید به همراه هر حالت دیگری، مانند متغیر محلی `i` در حلقه شما، پیگیری می‌کند. وقتی `MoveNext()` دوباره فراخوانی می‌شود، اجرا از نقطه‌ای که رسیده‌اید ادامه می‌یابد و پیش می‌رود. این چیزی است که آن را تنبل می‌کند، و این همان بخشی است که وقتی خودتان کد را می‌نویسید، درست کردن آن دشوار است.
</div>

### <div align="right">2.4.4 اهمیت تنبل بودن</div>

<div align="right">
برای اینکه ایده‌ای از اهمیت این موضوع به شما بدهم، بیایید کدی بنویسیم تا دنباله فیبوناچی را تا زمانی که به اولین مقدار بالای 1000 برسید، چاپ کند. لیست زیر یک متد `Fibonacci()` را نشان می‌دهد که یک دنباله بی‌نهایت را برمی‌گرداند و سپس یک متد که روی آن دنباله تکرار می‌شود تا زمانی که به یک حد برسد.
</div>

<div align="left">

```csharp
static IEnumerable<int> Fibonacci()
{
    int current = 0;
    int next = 1;
    while (true)
    {
        yield return current;
        int oldCurrent = current;
        current = next;
        next = next + oldCurrent;
    }
}
static void Main()
{
    foreach (var value in Fibonacci())
    {
        Console.WriteLine(value);
        if (value > 1000)
        {
            break;
        }
    }
}
```
</div>

<div align="right">
<div align="left">حلقه بی‌نهایت؟ فقط اگر باز هم درخواست کنید.</div>
<div align="left">مقدار فعلی فیبوناچی را تولید می‌کند.</div>
<div align="left">متد را برای به دست آوردن دنباله فراخوانی می‌کند.</div>
<div align="left">مقدار فعلی را چاپ می‌کند.</div>
<div align="left">شرط شکست.</div>
</div>

<div align="right">

چگونه می‌توانید کاری مانند این را بدون ایتریتورها انجام دهید؟ می‌توانید متد را تغییر دهید تا یک `List<int>` ایجاد کند و آن را تا زمانی که به حد برسید پر کند. اما آن لیست می‌تواند بزرگ باشد اگر حد بزرگ باشد، و چرا متدی که جزئیات دنباله فیبوناچی را می‌داند، باید بداند که شما چگونه می‌خواهید متوقف شوید؟ فرض کنید گاهی اوقات می‌خواهید بر اساس مدت زمانی که مقادیر را چاپ کرده‌اید، گاهی اوقات بر اساس تعداد مقادیری که چاپ کرده‌اید، و گاهی اوقات بر اساس مقدار فعلی، متوقف شوید. شما نمی‌خواهید متد را سه بار پیاده‌سازی کنید.
</div>

<div align="right">

لیست 2.13 تکرار روی دنباله فیبوناچی
</div>


<div align="right">

58 فصل 2 `C# 2`
</div>

<div align="right">

می‌توانید با چاپ مقدار در حلقه از ایجاد لیست اجتناب کنید، اما این باعث می‌شود متد `Fibonacci()` شما حتی بیشتر با یک چیزی که اتفاقاً می‌خواهید با مقادیر انجام دهید، `tightly coupled` شود. اگر می‌خواستید به جای چاپ مقادیر را با هم جمع کنید چه؟ آیا یک متد دوم می‌نوشتید؟ این همه یک نقض وحشتناک از تفکیک نگرانی‌ها (`separation of concerns`) است.
</div>

<div align="right">

راه حل ایتریتور دقیقاً همان چیزی است که می‌خواهید: نمایشی از یک دنباله بی‌نهایت، و همین. کد فراخوانی کننده می‌تواند تا جایی که می‌خواهد روی آن تکرار کند و از مقادیر هر طور که می‌خواهد استفاده کند.
</div>

<div align="right">

پیاده‌سازی دستی دنباله فیبوناچی چندان سخت نخواهد بود. وضعیت کمی برای نگهداری بین فراخوانی‌ها وجود دارد، و کنترل جریان ساده است. (این واقعیت که فقط یک دستور `yield return` وجود دارد، کمک می‌کند.) اما به محض پیچیده‌تر شدن کد، نمی‌خواهید این کد را خودتان بنویسید. کامپایلر نه تنها کدی را تولید می‌کند که ردیابی می‌کند کد به کجا رسیده است، بلکه در مورد نحوه مدیریت بلوک‌های `finally` نیز هوشمند است، که آنقدرها که فکر می‌کنید ساده نیستند.
</div>

### <div align="right">2.4.5 ارزیابی بلوک‌های `finally`</div>

<div align="right">

ممکن است عجیب به نظر برسد که من از میان تمام سینتکس‌هایی که `C#` برای مدیریت جریان اجرا دارد، روی بلوک‌های `finally` تمرکز کنم، اما نحوه مدیریت آنها در ایتریتورها هم جالب است و هم برای سودمندی این ویژگی مهم. در واقعیت، بسیار بیشتر احتمال دارد که از دستورات `using` به جای بلوک‌های `finally` خام استفاده کنید، اما می‌توانید دستورات `using` را به عنوان ساخته شده با بلوک‌های `finally` در نظر بگیرید، بنابراین همان رفتار برقرار است.
</div>

<div align="right">

برای نشان دادن نحوه عملکرد جریان اجرا، لیست زیر یک بلوک ایتریتور بی‌اهمیت را نشان می‌دهد که دو آیتم را در یک بلوک `try` تولید می‌کند و پیشرفت خود را به کنسول می‌نویسد. سپس متد را به دو روش استفاده خواهید کرد.
</div>

<div align="left">

```csharp
static IEnumerable<string> Iterator()
{
    try
    {
        Console.WriteLine("Before first yield");
        yield return "first";
        Console.WriteLine("Between yields");
        yield return "second";
        Console.WriteLine("After second yield");
    }
    finally
    {
        Console.WriteLine("In finally block");
    }
}
```
</div>

<div align="right">
8 حداقل تا زمانی که از محدوده `int` سرریز کند. در آن نقطه، ممکن است یک استثنا ایجاد کند یا به یک عدد منفی بزرگ زیر سرریز کند، بسته به اینکه کد در یک زمینه `checked` باشد یا خیر.
</div>

<div align="right">
لیست 2.14 یک ایتریتور که پیشرفت خود را ثبت می‌کند.
</div>

<div align="right">
ایتریتورها 59
قبل از اجرای آن، به این فکر کنید که اگر فقط روی دنباله بازگشتی توسط متد تکرار کنید، چه چیزی را انتظار دارید چاپ کند. به ویژه، آیا انتظار دارید هنگام بازگشت "`first`"، عبارت "`In finally block`" را در کنسول ببینید؟ دو راه برای فکر کردن به آن وجود دارد:
</div>

*   <div align="right">اگر اجرا را متوقف شده توسط دستور `yield return` در نظر بگیرید، منطقاً هنوز در بلوک `try` است و نیازی به اجرای بلوک `finally` نیست.</div>
*   <div align="right">اگر فکر می‌کنید کد واقعاً باید هنگام رسیدن به دستور `yield return` به فراخوانی کننده `MoveNext()` برگردد، پس احساس می‌کنید از بلوک `try` خارج می‌شوید و باید بلوک `finally` را به طور معمول اجرا کنید.</div>

<div align="right">
بدون اینکه بخواهم غافلگیری را خراب کنم، مدل مکث برنده است. بسیار مفیدتر است و از جنبه‌های دیگری که غیرشهودی به نظر می‌رسند، جلوگیری می‌کند. عجیب خواهد بود که هر دستور را در یک بلوک `try` فقط یک بار اجرا کنید، اما بلوک `finally` آن را سه بار اجرا کنید، برای مثال - یک بار برای هر بار که مقداری را تولید می‌کنید و سپس زمانی که بقیه متد را اجرا می‌کنید.
</div>

<div align="right">
بیایید ثابت کنیم که به این روش کار می‌کند. لیست زیر متد را فراخوانی می‌کند و روی مقادیر در دنباله تکرار می‌کند و آنها را هنگام پیشروی چاپ می‌کند.
</div>

<div align="left">

```csharp
static void Main()
{
    foreach (string value in Iterator())
    {
        Console.WriteLine("Received value: {0}", value);
    }
}
```
</div>

<div align="right">

خروجی لیست 2.15 نشان می‌دهد که بلوک `finally` فقط یک بار در انتها اجرا می‌شود:
</div>

```
Before first yield
Received value: first
Between yields
Received value: second
After second yield
In finally block
```

<div align="right">

این همچنین ثابت می‌کند که ارزیابی `lazy` در حال کار است: خروجی از متد `Main()` با خروجی از متد `Iterator()` در هم آمیخته است، زیرا ایتریتور به طور مکرر متوقف و از سر گرفته می‌شود.
</div>

<div align="right">

<div align="left">بسیار ساده است، اما این به این معنی است که شما باید تمام دنباله را تکرار می‌کردید. اگر بخواهید در میانه راه متوقف شوید چه؟ اگر کدی که آیتم‌ها را از یک ایتریتور واکشی می‌کند، `MoveNext()` را فقط یک بار فراخوانی کند (مثلاً اگر فقط به اولین مقدار از دنباله نیاز داشته باشد)، آیا این باعث می‌شود ایتریتور برای همیشه در بلوک `try` متوقف بماند بدون اینکه بلوک `finally` هرگز اجرا شود؟</div>
</div>

<div align="right">

لیست 2.15 یک حلقه `foreach` ساده برای تکرار و ثبت
</div>

<div align="right">

60 فصل 2 `C# 2`
پاسخ هم بله است و هم خیر. اگر همه فراخوانی‌ها به `IEnumerator<T>` را به صورت دستی بنویسید و `MoveNext()` را فقط یک بار فراخوانی کنید، بلوک `finally` واقعاً هرگز اجرا نخواهد شد. اما اگر یک حلقه `foreach` بنویسید و به طور تصادفی بدون حلقه زدن روی تمام دنباله از آن خارج شوید، بلوک `finally` اجرا خواهد شد. لیست زیر این را با خارج شدن از حلقه به محض دیدن یک مقدار غیر `null` (که البته بلافاصله انجام خواهد داد) نشان می‌دهد. این همان لیست 2.15 است اما با اضافه شدن قسمت پررنگ.
</div>

<div align="left">

```csharp
static void Main()
{
    foreach (string value in Iterator())
    {
        Console.WriteLine("Received value: {0}", value);
        if (value != null)
        {
            break;
        }
    }
}
```
</div>

<div align="right">

خروجی لیست 2.16 به شرح زیر است:
</div>

```
Before first yield
Received value: first
In finally block
```

<div align="right">

خط آخر مهم است: شما هنوز بلوک `finally` را اجرا می‌کنید. این به طور خودکار هنگام خروج از حلقه `foreach` اتفاق می‌افتد، زیرا یک دستور `using` پنهان دارد. لیست 2.17 نشان می‌دهد که اگر نمی‌توانستید از حلقه `foreach` استفاده کنید و مجبور بودید کد معادل را با دست بنویسید، لیست 2.16 چگونه به نظر می‌رسید. اگر این آشنا به نظر می‌رسد، به این دلیل است که شما همین کار را در لیست 2.12 انجام دادید، اما این بار بیشتر به دستور `using` توجه می‌کنید.
</div>


<div align="left">

```csharp
static void Main()
{
    IEnumerable<string> enumerable = Iterator();
    using (IEnumerator<string> enumerator = enumerable.GetEnumerator())
    {
        while (enumerator.MoveNext())
        {
            string value = enumerator.Current;
            Console.WriteLine("Received value: {0}", value);
            if (value != null)
            {
                break;
            }
        }
    }
}
```
</div>

<div align="right">

لیست 2.16 خارج شدن از یک حلقه `foreach` با استفاده از یک ایتریتور
لیست 2.17 بسط لیست 2.16 برای عدم استفاده از حلقه `foreach`
</div>

<div align="right">
ایتریتورها 61
بخش مهم دستور `using` است. این اطمینان می‌دهد که هر طور که آن را ترک کنید، `Dispose()` را روی `IEnumerator<string>` فراخوانی خواهید کرد. اگر متد ایتریتور در آن نقطه در بلوک `try` "متوقف" شده باشد، متد `Dispose()` در نهایت بلوک `finally` را اجرا می‌کند. باهوش نیست؟
</div>

### <div align="right">2.4.6 اهمیت مدیریت `finally`</div>

<div align="right">

این ممکن است جزئیات کوچکی به نظر برسد، اما تفاوت بسیار زیادی در نحوه کاربرد ایتریتورها ایجاد می‌کند. به این معنی است که می‌توان از آنها برای متدهایی استفاده کرد که منابعی را به دست می‌آورند که نیاز به `disposing` دارند، مانند دسته‌های فایل. همچنین به این معنی است که می‌توان از آنها برای زنجیره کردن به سایر ایتریتورها با همان نیاز استفاده کرد. در فصل 3 خواهید دید که `LINQ to Objects` از دنباله‌ها زیاد استفاده می‌کند، و `disposal` قابل اعتماد برای کار با فایل‌ها و سایر منابع بسیار مهم است.
</div>

<div align="right">

به عنوان مثالی از مفید بودن به دست آوردن منابع در بلوک‌های ایتریتور، لیست زیر را در نظر بگیرید که متدی را نشان می‌دهد که دنباله‌ای از خطوط خوانده شده از یک فایل را برمی‌گرداند.
</div>

<div align="left">

```csharp
static IEnumerable<string> ReadLines(string path)
{
    using (TextReader reader = File.OpenText(path))
    {
        string line;
        while ((line = reader.ReadLine()) != null)
        {
            yield return line;
        }
    }
}
```
</div>

<div align="right">

یک متد مانند این در `NET 4.0` (`File.ReadLines`) معرفی شد، اما متد چارچوب خوب کار نمی‌کند اگر یک بار متد را فراخوانی کنید اما روی نتیجه تکرار کنید.
</div>

<div align="right">

<div align="left">همه اینها مستلزم آن است که فراخواننده ایتریتور را `dispose` کند.</div>
</div>

<div align="right">

اگر `Dispose()` را روی یک ایتریتور فراخوانی نکنید (و تا انتهای دنباله تکرار نکرده‌اید)، ممکن است منابع نشت کنند یا حداقل پاکسازی به تعویق بیفتد. از این باید اجتناب شود. رابط `IEnumerator` غیر عمومی `IDisposable` را گسترش نمی‌دهد، اما حلقه `foreach` بررسی می‌کند که آیا پیاده‌سازی زمان اجرا نیز `IDisposable` را پیاده‌سازی می‌کند یا خیر، و در صورت لزوم `Dispose()` را فراخوانی می‌کند. رابط `IEnumerator<T>` عمومی `IDisposable` را گسترش می‌دهد و کارها را ساده‌تر می‌کند.
</div>

<div align="right">

اگر با فراخوانی دستی `MoveNext()` تکرار می‌کنید (که قطعاً جایگاه خود را دارد)، باید همین کار را انجام دهید. اگر روی یک `IEnumerable<T>` عمومی تکرار می‌کنید، می‌توانید فقط از یک دستور `using` استفاده کنید، همانطور که من در لیست‌های حلقه `foreach` بسط یافته خود انجام داده‌ام. اگر در موقعیت نامناسب تکرار روی یک دنباله غیر عمومی هستید، باید همان بررسی رابط را انجام دهید که کامپایلر در `foreach` انجام می‌دهد.
</div>

<div align="right">

لیست 2.18 خواندن خطوط از یک فایل
</div>




<div align="right">
62 فصل 2 `C# 2`
</div>

<div align="right">
چندین بار؛ این فایل را فقط یک بار باز می‌کند. متد در لیست 2.18 فایل را هر بار که تکرار می‌کنید باز می‌کند، که استدلال در مورد آن را ساده‌تر می‌کند. با این حال، این جنبه منفی تأخیر در هرگونه استثنا به دلیل عدم وجود فایل یا عدم قابل خواندن بودن آن را دارد.
</div>

<div align="right">
مبادله‌های پیچیده همیشه در طراحی `API` وجود دارند.
</div>

<div align="right">
هدف از نشان دادن این متد به شما، اثبات اهمیت مدیریت صحیح `iterator disposal` است. اگر یک حلقه `foreach` که استثنا ایجاد می‌کرد یا زود بازمی‌گشت، منجر به یک دستگیره فایل باز معلق می‌شد، متد تقریباً بی‌فایده می‌بود. قبل از ترک ایتریتورها، بیایید لحظه‌ای به پشت پرده نگاهی بیندازیم و ببینیم چگونه آنها پیاده‌سازی می‌شوند.
</div>

### <div align="right">2.4.7 طرح کلی پیاده‌سازی (`Implementation sketch`)</div>

<div align="right">

همیشه برایم مفید است که ببینم کامپایلر (`compiler`) تقریباً چه کاری با کد انجام می‌دهد، به ویژه برای موقعیت‌های پیچیده مانند ایتریتورها (`iterators`)، `async/await` و توابع ناشناس (`anonymous functions`). این بخش فقط طعمی از آن را ارائه می‌دهد؛ مقاله‌ای در `http://csharpindepth.com` جزئیات بسیار بیشتری را فراهم می‌کند. لطفاً توجه داشته باشید که جزئیات دقیق، وابسته به پیاده‌سازی (`implementation specific`) هستند؛ ممکن است کامپایلرهای مختلف رویکردهای کمی متفاوتی را در پیش بگیرند. با این حال، انتظار دارم اکثر آنها استراتژی اساسی یکسانی داشته باشند.
</div>

<div align="right">

اولین چیزی که باید درک کنید این است که حتی با وجود اینکه شما یک متد نوشته‌اید، کامپایلر یک نوع کاملاً جدید برای شما تولید می‌کند تا رابط‌های مربوطه را پیاده‌سازی کند. بدنه متد شما به یک متد `MoveNext()` در این نوع تولید شده منتقل می‌شود و برای معناشناسی اجرای ایتریتورها تنظیم می‌شود. برای نشان دادن کد تولید شده، به کدی که کامپایلر برای لیست زیر تولید می‌کند نگاه خواهیم کرد.
</div>

<div align="left">

```csharp
public static IEnumerable<int> GenerateIntegers(int count)
{
    try
    {
        for (int i = 0; i < count; i++)
        {
            Console.WriteLine("Yielding {0}", i);
            yield return i;
            int doubled = i * 2;
            Console.WriteLine("Yielding {0}", doubled);
            yield return doubled;
        }
    }
    finally
    {
        Console.WriteLine("In finally block");
    }
}
```
</div>

<div align="right">
9 می‌توانید از ایتریتورها برای نوشتن دسترسی‌کننده‌های ویژگی (`property accessors`) نیز استفاده کنید، اما برای بقیه این بخش، فقط در مورد متدهای ایتریتور صحبت خواهم کرد، فقط برای مختصر بودن. پیاده‌سازی برای دسترسی‌کننده‌های ویژگی یکسان است.
</div>

<div align="right">
لیست 2.19 متد ایتریتور نمونه برای دی‌کامپایل
</div>

<div align="right">

ایتریتورها 63
لیست 2.19 یک متد نسبتاً ساده را در شکل اصلی خود نشان می‌دهد، اما من عمداً پنج جنبه را که ممکن است آشکار به نظر نرسند، گنجانده‌ام:
</div>

*   <div align="right">یک پارامتر (`parameter`)</div>
*   <div align="right">یک متغیر محلی (`local variable`) که باید در دستورات `yield return` حفظ شود</div>
*   <div align="right">یک متغیر محلی که نیازی به حفظ شدن در دستورات `yield return` ندارد</div>
*   <div align="right">دو دستور `yield return`</div>
*   <div align="right">یک بلوک `finally`</div>

<div align="right">

این متد به اندازه `count` بار در حلقه خود تکرار می‌شود و در هر تکرار دو عدد صحیح را `yield` می‌کند: شماره تکرار و دو برابر همان مقدار. به عنوان مثال، اگر 5 را وارد کنید، 0، 0، 1، 2، 2، 4، 3، 6، 4، 8 را `yield` خواهد کرد.
</div>

<div align="right">

کد منبع قابل دانلود شامل یک فرم کامل، دستی تنظیم شده و دی‌کامپایل شده از کد تولید شده است. بسیار طولانی است، بنابراین من آن را به طور کامل در اینجا نیاورده‌ام. در عوض، می‌خواهم طعمی از آنچه تولید می‌شود را به شما بدهم. لیست زیر بیشتر زیرساخت (`infrastructure`) را نشان می‌دهد اما هیچ یک از جزئیات پیاده‌سازی را نشان نمی‌دهد. آن را توضیح خواهم داد، و سپس به متد `MoveNext()` نگاه خواهیم کرد که بیشتر کار واقعی را انجام می‌دهد.
</div>

<div align="left">

```csharp
public static IEnumerable<int> GenerateIntegers(
    int count)
{
    GeneratedClass ret = new GeneratedClass(-2);
    ret.count = count;
    return ret;
}
private class GeneratedClass
    : IEnumerable<int>, IEnumerator<int>
{
    public int count;
    private int state;
    private int current;
    private int initialThreadId;
    private int i;
    public GeneratedClass(int state)
    {
        this.state = state;
        initialThreadId = Environment.CurrentManagedThreadId;
    }
    public bool MoveNext() { ... }
    public IEnumerator<int> GetEnumerator() { ... }
    public void Reset()
    {
        throw new NotSupportedException();
    }
}
```
</div>

<div align="right">

لیست 2.20 زیرساخت کد تولید شده برای یک ایتریتور
</div>

<div align="right">
<div align="left">متد `Stub` با امضای اصلی اعلام شده</div>
<div align="left">کلاس تولید شده برای نمایش ماشین حالت (`state machine`)</div>
<div align="left">تمام فیلدها (`fields`) در ماشین حالت با اهداف مختلف</div>
<div align="left">سازنده (`Constructor`) که هم توسط متد `stub` و هم توسط `GetEnumerator` فراخوانی می‌شود.</div>
<div align="left">بدنه اصلی کد ماشین حالت</div>
<div align="left">در صورت لزوم، یک ماشین حالت جدید ایجاد می‌کند.</div>
<div align="left">ایتریتورهای تولید شده هرگز از `Reset` پشتیبانی نمی‌کنند.</div>
</div>



<div align="right">

64 فصل 2 `C# 2`
</div>

<div align="left">

```csharp
public void Dispose() { ... }
public int Current { get { return current; } }
private void Finally1() { ... }
IEnumerator Enumerable().GetEnumerator()
{
    return GetEnumerator();
}
object IEnumerator.Current { get { return current; } }
}
```
</div>

<div align="right">
بله، این نسخه ساده شده است. نکته مهمی که باید درک کنید این است که کامپایلر یک ماشین حالت (`state machine`) را برای شما، به عنوان یک کلاس تو در تو خصوصی (`private nested class`)، تولید می‌کند. بسیاری از نام‌های تولید شده توسط کامپایلر شناساگرهای `C#` معتبری نیستند، اما من برای سادگی، شناساگرهای معتبر را ارائه کرده‌ام. کامپایلر هنوز هم یک متد با امضای اعلان شده در کد منبع اصلی را منتشر می‌کند، و این همان چیزی است که فراخوانندگان (`callers`) از آن استفاده خواهند کرد. تمام کاری که انجام می‌دهد این است که یک نمونه از ماشین حالت را ایجاد کند، هر پارامتر را به آن کپی کند و ماشین حالت را به فراخواننده برگرداند. هیچ یک از کد منبع اصلی فراخوانی نمی‌شود، که با رفتار تنبل (`lazy behavior`) که قبلاً دیده‌اید مطابقت دارد.
</div>

<div align="right">
ماشین حالت شامل تمام آنچه برای پیاده‌سازی ایتریتور نیاز دارد است:
</div>

*   <div align="right">نشانگری از اینکه در کجای متد هستید. این شبیه به یک شمارنده دستورالعمل (`instruction counter`) در یک `CPU` است اما ساده‌تر است زیرا فقط باید بین چند حالت تمایز قائل شوید.</div>
*   <div align="right">یک کپی از تمام پارامترها، بنابراین می‌توانید مقادیر آنها را در صورت نیاز به دست آورید.</div>
*   <div align="right">متغیرهای محلی (`local variables`) در متد</div>
*   <div align="right">آخرین مقدار `yield` شده، بنابراین فراخواننده می‌تواند آن را با خاصیت `Current` به دست آورد.</div>

<div align="right">
شما انتظار دارید که فراخواننده دنباله عملیات زیر را انجام دهد:
</div>

1.  <div align="right">`GetEnumerator()` را فراخوانی کنید تا یک `IEnumerator<int>` به دست آورید.</div>
2.  <div align="right">به طور مکرر `MoveNext()` و سپس `Current` را روی `IEnumerator<int>` فراخوانی کنید تا زمانی که `MoveNext()` مقدار `false` را برگرداند.</div>
3.  <div align="right">`Dispose()` را برای هرگونه پاکسازی مورد نیاز فراخوانی کنید، چه یک استثنا (`exception`) پرتاب شده باشد یا نه.</div>

<div align="right">

تقریباً در همه موارد، ماشین حالت فقط یک بار و فقط در همان رشته‌ای (`thread`) که ایجاد شده است، استفاده می‌شود. کامپایلر کدی را برای بهینه‌سازی (`optimize`) این مورد تولید می‌کند؛ متد `GetEnumerator()` آن را بررسی می‌کند و اگر ماشین حالت هنوز در حالت اولیه خود باشد و در همان رشته باشد، `this` را برمی‌گرداند. به همین دلیل است که ماشین حالت هم `IEnumerable<int>` و هم `IEnumerator<int>` را پیاده‌سازی می‌کند، که دیدن آن در کد معمولی غیرعادی است.10 اگر `GetEnumerator()` از رشته دیگری فراخوانی شود یا چندین بار، آن فراخوانی‌ها یک نمونه جدید از ماشین حالت را با مقادیر پارامتر اولیه کپی شده ایجاد می‌کنند.
</div>

<div align="right">
10 اگر متد اصلی فقط `IEnumerator<T>` را برمی‌گرداند، ماشین حالت فقط آن را پیاده‌سازی می‌کند.
</div>

<div align="right">
<div align="left">بلوک‌های `finally` را اجرا می‌کند، در صورت نیاز</div>
<div align="left">خاصیت `Current` برای بازگرداندن آخرین مقدار `yield` شده</div>
<div align="left">بدنه یک بلوک `finally` برای استفاده در `MoveNext` و `Dispose`</div>
<div align="left">پیاده‌سازی صریح (`Explicit implementation`) اعضای رابط غیر جنریک (`nongeneric interface`)</div>
</div>

<div align="right">

ایتریتورها 65
متد `MoveNext()` بخش پیچیده است. اولین باری که فراخوانی می‌شود، فقط باید اجرای کد نوشته شده در متد را به طور معمول آغاز کند؛ اما در فراخوانی‌های بعدی، باید به طور مؤثر به نقطه صحیح در متد پرش کند. متغیرهای محلی (`local variables`) نیز باید بین فراخوانی‌ها حفظ شوند، بنابراین در فیلدهای (`fields`) ماشین حالت ذخیره می‌شوند.
</div>

<div align="right">

در یک ساخت بهینه‌سازی شده (`optimized build`)، برخی از متغیرهای محلی نیازی به کپی شدن در فیلدها ندارند. هدف از استفاده از یک فیلد این است که بتوانید مقداری را که در یک فراخوانی `MoveNext()` تنظیم کرده‌اید، هنگام بازگشت در فراخوانی `MoveNext()` بعدی، پیگیری کنید. اگر به متغیر محلی `doubled` از لیست 2.19 نگاه کنید، هرگز به این صورت استفاده نمی‌شود:
</div>

<div align="left">

```csharp
for (int i = 0; i < count; i++)
{
    Console.WriteLine("Yielding {0}", i);
    yield return i;
    int doubled = i * 2;
    Console.WriteLine("Yielding {0}", doubled);
    yield return doubled;
}
```
</div>

<div align="right">

تنها کاری که انجام می‌دهید این است که متغیر را مقداردهی اولیه (`initialize`) کنید، آن را چاپ کنید، و سپس آن را `yield` کنید. هنگامی که به متد بازمی‌گردید، آن مقدار بی‌اهمیت است، بنابراین کامپایلر می‌تواند آن را در یک ساخت نهایی (`release build`) به یک متغیر محلی واقعی بهینه‌سازی کند. در یک ساخت اشکال‌زدایی (`debug build`)، ممکن است هنوز برای بهبود تجربه اشکال‌زدایی وجود داشته باشد. توجه داشته باشید که اگر دو خط پررنگ آخر را در کد قبلی جابجا می‌کردید – یعنی ابتدا مقدار را `yield` می‌کردید و سپس آن را چاپ می‌کردید – بهینه‌سازی ممکن نبود.
</div>

<div align="right">

یک متد `MoveNext()` چگونه به نظر می‌رسد؟ ارائه کد واقعی بدون گرفتار شدن در جزئیات بیش از حد دشوار است، بنابراین لیست زیر طرحی از ساختار را ارائه می‌دهد.
</div>

<div align="left">

```csharp
public bool MoveNext()
{
    try
    {
        switch (state)
        {
        }
    }
    fault
    {
        Dispose();
    }
}
```
</div>

<div align="right">

لیست 2.21 متد `MoveNext()` ساده شده
</div>

<div align="right">
<div align="left">جدول پرش (`Jump table`) برای رسیدن به بخش صحیح بقیه متد</div>
<div align="left">کد متد که در هر `yield return` بازمی‌گردد</div>
<div align="left">بلوک `Fault` که فقط در استثناها اجرا می‌شود.</div>
<div align="left">پاکسازی در استثناها</div>
</div>

<div align="right">

66 فصل 2 `C# 2`
ماشین حالت شامل متغیری (در مورد ما، `state` نامیده می‌شود) است که به خاطر می‌سپارد به کجا رسیده است. مقادیر دقیقی که استفاده می‌شوند به پیاده‌سازی (`implementation`) بستگی دارد، اما در نسخه‌ای از `Roslyn` که من از آن استفاده کردم، حالت‌ها به طور مؤثر به شرح زیر بودند:
</div>

*   <div align="right">`-3` - `MoveNext()` در حال حاضر در حال اجرا است.</div>
*   <div align="right">`-2` - `GetEnumerator()` هنوز فراخوانی نشده است.</div>
*   <div align="right">`-1` - تکمیل شده (چه با موفقیت و چه بدون آن).</div>
*   <div align="right">`0` - `GetEnumerator()` فراخوانی شده اما `MoveNext()` هنوز فراخوانی نشده است (شروع متد).</div>
*   <div align="right">`1` - در اولین دستور `yield return`.</div>
*   <div align="right">`2` - در دومین دستور `yield return`.</div>

<div align="right">
هنگامی که `MoveNext()` فراخوانی می‌شود، از این حالت برای پرش به مکان صحیح در متد استفاده می‌کند تا یا برای اولین بار شروع به اجرا کند یا از دستور `yield return` قبلی ادامه یابد. توجه داشته باشید که هیچ حالتی برای موقعیت‌های کد مانند "فقط یک مقدار به متغیر `doubled` اختصاص داده شده" وجود ندارد، زیرا شما هرگز نیازی به ادامه از آنجا ندارید؛ فقط باید از جایی که قبلاً متوقف شده بودید ادامه دهید.
</div>



<div align="right">
66 فصل 2 `C# 2`
</div>

<div align="right">
بلوک `fault` نزدیک انتهای لیست 2.21 یک ساختار `IL` است که معادل مستقیمی در `C#` ندارد. این مانند یک بلوک `finally` است که هنگام پرتاب شدن یک استثنا اجرا می‌شود اما بدون گرفتن استثنا. از این برای انجام هرگونه عملیات پاکسازی مورد نیاز استفاده می‌شود؛ در مورد ما، این همان بلوک `finally` است. کد در آن بلوک `finally` به یک متد جداگانه منتقل می‌شود که از `Dispose()` (اگر استثنایی پرتاب شده باشد) و `MoveNext()` (اگر بدون استثنا به آن برسید) فراخوانی می‌شود. متد `Dispose()` حالت را بررسی می‌کند تا ببیند چه پاکسازی مورد نیاز است. هر چه بلوک‌های `finally` بیشتری وجود داشته باشد، این پیچیده‌تر می‌شود.
</div>

<div align="right">
نگاه کردن به پیاده‌سازی (`implementation`) از نظر آموزش تکنیک‌های برنامه‌نویسی `C#` بیشتر، روشنگر نیست، اما برای ایجاد قدردانی از میزان توانایی کامپایلر از طرف شما عالی است. همین ایده‌ها دوباره در `C# 5` با `async/await` به کار گرفته می‌شوند، جایی که به جای مکث تا زمانی که `MoveNext()` دوباره فراخوانی شود، متدهای ناهمزمان (`asynchronous methods`) به طور مؤثر تا زمانی که یک عملیات ناهمزمان تکمیل شود، مکث می‌کنند.
</div>

<div align="right">
اکنون بزرگترین ویژگی‌های `C# 2` را پوشش داده‌ایم، اما چندین ویژگی کوچکتر همزمان معرفی شدند. توصیف این ویژگی‌ها نسبتاً ساده است، به همین دلیل من همه آنها را در اینجا جمع کرده‌ام. آنها در غیر این صورت به هم مرتبط نیستند، اما گاهی اوقات طراحی زبان به همین شکل اتفاق می‌افتد.
</div>

## <div align="right">2.5 ویژگی‌های جزئی (`Minor features`)</div>

<div align="right">
برخی از ویژگی‌های توصیف شده در این بخش، طبق تجربه من، به ندرت استفاده می‌شوند، اما برخی دیگر در هر پایگاه کد مدرن `C#` رایج هستند. زمان لازم برای توصیف یک ویژگی همیشه با میزان مفید بودن آن ارتباط ندارد. در این بخش، موارد زیر را بررسی خواهیم کرد:
</div>

*   <div align="right">انواع جزئی (`Partial types`) که امکان تقسیم کد برای یک نوع واحد را در چندین فایل منبع (`source files`) فراهم می‌کنند.</div>
*   <div align="right">کلاس‌های `static` برای انواع `utility`</div>
*   <div align="right">دسترسی‌پذیری جداگانه (`public, private` و غیره) برای دسترسی‌کننده‌های `get` و `set` در ویژگی‌ها (`properties`).</div>

<div align="right">
ویژگی‌های جزئی 67
</div>

*   <div align="right">بهبودهای `alias`های فضای نام (`namespace aliases`) برای آسان‌تر کردن کار با کدی که از نام‌های یکسان در چندین فضای نام یا `assembly` استفاده می‌کند.</div>
*   <div align="right">دستورالعمل‌های `Pragma` که امکان ویژگی‌های خاص کامپایلر اضافی مانند غیرفعال کردن موقت هشدارها را فراهم می‌کنند.</div>
*   <div align="right">بافرهای با اندازه ثابت (`Fixed-size buffers`) برای داده‌های درون خطی در کد ناایمن (`unsafe code`).</div>
*   <div align="right">`Attribute` (صفت) `[InternalsVisibleTo]` که آزمایش (`testing`) را ساده‌تر می‌کند.</div>

<div align="right">
هر ویژگی مستقل از بقیه است و ترتیبی که من آنها را توصیف کرده‌ام مهم نیست. اگر فقط به اندازه کافی در مورد یکی از این بخش‌ها می‌دانید که برای شما بی‌اهمیت است، می‌توانید با خیال راحت آن را رد کنید بدون اینکه بعداً مشکلی ایجاد شود.
</div>

### <div align="right">2.5.1 انواع جزئی (`Partial types`)</div>

<div align="right">
انواع جزئی به یک کلاس (`class`)، ساختار (`struct`) یا رابط (`interface`) واحد اجازه می‌دهند تا در چندین بخش و معمولاً در چندین فایل منبع اعلام شوند. این معمولاً با تولیدکننده‌های کد (`code generators`) استفاده می‌شود. چندین تولیدکننده کد می‌توانند بخش‌های مختلفی را به یک نوع واحد کمک کنند، و اینها می‌توانند با کد نوشته شده دستی بیشتر تقویت شوند. بخش‌های مختلف توسط کامپایلر ترکیب می‌شوند و طوری عمل می‌کنند که گویی همه با هم اعلام شده‌اند.
</div>

<div align="right">
انواع جزئی با افزودن اصلاح کننده `partial` به اعلان نوع، اعلام می‌شوند. این باید در هر بخش وجود داشته باشد. لیست زیر مثالی با دو بخش را نشان می‌دهد و نشان می‌دهد که چگونه یک متد اعلام شده در یک بخش می‌تواند در بخش دیگری استفاده شود.
</div>

<div align="left">

```csharp
partial class PartialDemo
{
    public static void MethodInPart1()
    {
        MethodInPart2();
    }
}
partial class PartialDemo
{
    private static void MethodInPart2()
    {
        Console.WriteLine("In MethodInPart2");
    }
}
```
</div>

<div align="right">

اگر نوع جنریک (`generic`) باشد، هر بخش باید مجموعه پارامترهای نوع یکسانی را با نام‌های یکسان اعلام کند، اگرچه اگر چندین اعلان، یک پارامتر نوع یکسان را محدود کنند، آن محدودیت‌ها باید یکسان باشند. بخش‌های مختلف می‌توانند رابط‌های مختلفی را که یک نوع پیاده‌سازی می‌کند، ارائه دهند، و پیاده‌سازی نیازی به بودن در بخشی که رابط را مشخص می‌کند، ندارد.
</div>

<div align="right">

لیست 2.22 یک کلاس جزئی ساده
</div>

<div align="right">

<div align="left">از متد اعلام شده در بخش دوم استفاده می‌کند.</div>
<div align="left">متد مورد استفاده در بخش اول.</div>
</div>

<div align="right">
68 فصل 2 `C# 2`
</div>

<div align="right">

<div align="right">متدهای جزئی (`PARTIAL METHODS`) (`C# 3`)</div>
</div>

<div align="right">
`C# 3` یک ویژگی اضافی به انواع جزئی به نام متدهای جزئی معرفی کرد. اینها متدهایی هستند که بدون بدنه در یک بخش اعلام می‌شوند و سپس به صورت اختیاری در بخش دیگری پیاده‌سازی می‌شوند. متدهای جزئی به طور ضمنی `private` هستند و باید `void` باشند بدون پارامتر `out`. (استفاده از پارامترهای `ref` مشکلی ندارد.) در زمان کامپایل (`compile time`)، فقط متدهای جزئی که پیاده‌سازی شده‌اند حفظ می‌شوند؛ اگر یک متد جزئی پیاده‌سازی نشده باشد، تمام فراخوانی‌ها به آن حذف می‌شوند. این عجیب به نظر می‌رسد، اما به کد تولید شده اجازه می‌دهد تا قلاب‌های اختیاری (`optional hooks`) را برای کد نوشته شده دستی فراهم کند تا رفتار اضافی اضافه کند. معلوم می‌شود که واقعاً مفید است. لیست زیر مثالی با دو متد جزئی را ارائه می‌دهد که یکی از آنها پیاده‌سازی شده و دیگری نشده است.
</div>

<div align="left">

```csharp
partial class PartialMethodsDemo
{
    public PartialMethodsDemo()
    {
        OnConstruction();
    }
    public override string ToString()
    {
        string ret = "Original return value";
        CustomizeToString(ref ret);
        return ret;
    }
    partial void OnConstruction();
    partial void CustomizeToString(ref string text);
}
partial class PartialMethodsDemo
{
    partial void CustomizeToString(ref string text)
    {
        text += " - customized!";
    }
}
```
</div>

<div align="right">

در لیست 2.23، بخش اول به احتمال زیاد کد تولید شده (`generated code`) خواهد بود، که امکان رفتار اضافی در زمان ساخت و هنگام به دست آوردن یک نمایش رشته‌ای (`string representation`) از شیء را فراهم می‌کند. بخش دوم مربوط به کد نوشته شده دستی است که نیازی به سفارشی‌سازی ساخت ندارد اما می‌خواهد نمایش رشته‌ای بازگردانده شده توسط `ToString()` را تغییر دهد. حتی با وجود اینکه متد `CustomizeToString` نمی‌تواند مستقیماً مقداری را برگرداند، می‌تواند با یک پارامتر `ref` به طور مؤثر اطلاعات را به فراخواننده خود بازگرداند.
</div>



<div align="right">

از آنجا که `OnConstruction` هرگز پیاده‌سازی نمی‌شود، به طور کامل توسط کامپایلر حذف می‌شود. اگر یک متد جزئی با پارامترها فراخوانی شود، آرگومان‌ها حتی در صورت عدم پیاده‌سازی هرگز ارزیابی نمی‌شوند.
</div>

<div align="right">
لیست 2.23 دو متد جزئی - یکی پیاده‌سازی شده، یکی نشده
</div>

<div align="right">
<div align="left">فراخوانی به متد جزئی پیاده‌سازی نشده</div>
<div align="left">فراخوانی به متد جزئی پیاده‌سازی شده</div>
<div align="left">اعلان‌های متد جزئی</div>
<div align="left">پیاده‌سازی متد جزئی</div>
</div>

<div align="right">
ویژگی‌های جزئی 69
اگر تا به حال خود را در حال نوشتن یک تولیدکننده کد (`code generator`) یافتید، به شدت شما را تشویق می‌کنم که کلاس‌های `partial` تولید کنید. همچنین ممکن است مفید باشد که در کدهای کاملاً دست‌نویس نیز کلاس‌های `partial` ایجاد کنید؛ برای مثال، من از این برای تقسیم تست‌ها برای کلاس‌های بزرگ به چندین فایل منبع برای سازماندهی آسان استفاده کرده‌ام.
</div>

### <div align="right">2.5.2 کلاس‌های `Static`</div>

<div align="right">
کلاس‌های `Static` کلاس‌هایی هستند که با اصلاح کننده `static` اعلام می‌شوند. اگر تا به حال خود را در حال نوشتن کلاس‌های `utility` که به طور کامل از متدهای `static` تشکیل شده‌اند، دیده‌اید، اینها کاندیدای اصلی برای کلاس‌های `static` هستند. کلاس‌های `Static` نمی‌توانند متدهای نمونه (`instance methods`)، ویژگی‌ها (`properties`)، رویدادها (`events`) یا سازنده‌ها (`constructors`) را اعلام کنند، اما می‌توانند انواع تو در تو (`nested types`) معمولی را شامل شوند.
</div>

<div align="right">
اگرچه اعلام یک کلاس معمولی با تنها اعضای `static` کاملاً معتبر است، اضافه کردن اصلاح کننده `static`، قصد شما را از نظر نحوه استفاده از کلاس نشان می‌دهد. کامپایلر می‌داند که کلاس‌های `static` هرگز نمی‌توانند نمونه‌سازی شوند، بنابراین از استفاده آنها به عنوان انواع متغیر یا آرگومان‌های نوع جلوگیری می‌کند. لیست زیر یک مثال کوتاه از آنچه مجاز است و آنچه مجاز نیست را ارائه می‌دهد.
</div>

<div align="left">

```csharp
static class StaticClassDemo
{
    public static void StaticMethod() { }
    public void InstanceMethod() { } // نامعتبر
    public class RegularNestedClass
    {
        public void InstanceMethod() { }
    }
}
...
StaticClassDemo.StaticMethod();
StaticClassDemo localVariable = null; // نامعتبر
List<StaticClassDemo> list =
new List<StaticClassDemo>(); // نامعتبر
```
</div>

<div align="right">
کلاس‌های `Static` رفتار خاص اضافی دارند به این صورت که متدهای `extension` (معرفی شده در `C# 3`) فقط می‌توانند در کلاس‌های `static`، غیر تو در تو (`non-nested`) و غیر جنریک (`nongeneric`) اعلام شوند.
</div>

### <div align="right">2.5.3 دسترسی `getter/setter` جداگانه برای ویژگی‌ها (`properties`)</div>

<div align="right">
باور کردنش سخت است، اما در `C# 1`، یک ویژگی فقط یک اصلاح کننده دسترسی (`access modifier`) داشت که هم برای `getter` و هم برای `setter` استفاده می‌شد، با فرض اینکه هر دو وجود داشتند. `C# 2` توانایی ایجاد یک دسترسی‌کننده خصوصی‌تر از دیگری را با افزودن یک اصلاح کننده به آن دسترسی‌کننده خصوصی‌تر معرفی کرد. این تقریباً همیشه برای خصوصی‌تر کردن `setter` از `getter` استفاده می‌شود، و تا حد زیادی رایج‌ترین ترکیب داشتن یک `getter` عمومی و یک `setter` خصوصی است، به این صورت:
</div>

<div align="left">

```csharp
private string text;
public string Text
{
    get { return text; }
    private set { text = value; }
}
```
</div>

<div align="right">
لیست 2.24 نمایش کلاس‌های `static`
</div>

<div align="right">
<div align="left">صحیح: کلاس‌های `static` می‌توانند متدهای `static` را اعلام کنند.</div>
<div align="left">نامعتبر: کلاس‌های `static` نمی‌توانند متدهای نمونه را اعلام کنند.</div>
<div align="left">صحیح: کلاس‌های `static` می‌توانند انواع تو در تو معمولی را اعلام کنند.</div>
<div align="left">صحیح: یک نوع معمولی تو در تو در یک کلاس `static` می‌تواند یک متد نمونه را اعلام کند.</div>
<div align="left">صحیح: فراخوانی یک متد `static` از یک کلاس `static`</div>
<div align="left">نامعتبر: نمی‌توان یک متغیر از یک کلاس `static` را اعلام کرد.</div>
<div align="left">نامعتبر: نمی‌توان از یک کلاس `static` به عنوان آرگومان نوع استفاده کرد.</div>
</div>

<div align="right">
70 فصل 2 `C# 2`
در این مثال، هر کدی که به `setter` ویژگی دسترسی دارد، می‌تواند مستقیماً مقدار فیلد را تنظیم کند، اما در موقعیت‌های پیچیده‌تر، ممکن است بخواهید اعتبارسنجی (`validation`) یا اعلان تغییر (`change notification`) را اضافه کنید. استفاده از یک ویژگی اجازه می‌دهد تا رفتاری مانند این به خوبی کپسوله شود. اگرچه این را می‌توان به جای آن در یک متد قرار داد، استفاده از یک ویژگی در `C#` اصیل‌تر به نظر می‌رسد.
</div>

### <div align="right">2.5.4 `Alias`های فضای نام (`Namespace aliases`)</div>

<div align="right">

فضاهای نام (`namespaces`) برای اجازه دادن به اعلان چندین نوع با نام یکسان اما در فضاهای نام مختلف استفاده می‌شوند. این از نام‌های نوع طولانی و پیچیده فقط به خاطر منحصر به فرد بودن جلوگیری می‌کند. `C# 1` قبلاً از فضاهای نام و حتی `alias`های فضای نام پشتیبانی می‌کرد تا بتوانید در صورتی که یک قطعه کد واحد داشتید که نیاز به استفاده از انواع با نام یکسان از فضاهای نام مختلف داشت، مشخص کنید که منظور کدام نوع است. لیست زیر نشان می‌دهد که چگونه یک متد می‌تواند به کلاس‌های `Button` از هر دو `Windows Forms` و `ASP.NET Web Forms` اشاره کند.
</div>

<div align="left">

```csharp
using System;
using WinForms = System.Windows.Forms;
using WebForms = System.Web.UI.WebControls;
class Test
{
    static void Main()
    {
        Console.WriteLine(typeof(WinForms.Button));
        Console.WriteLine(typeof(WebForms.Button));
    }
}
```
</div>

<div align="right">
`C# 2` پشتیبانی از `alias`های فضای نام را به سه روش مهم گسترش می‌دهد.
</div>

<div align="right">
<div align="right">سینتکس تعیین کننده `alias` فضای نام (`NAMESPACE ALIAS QUALIFIER SYNTAX`)</div>
</div>

<div align="right">
سینتکس `WinForms.Button` در لیست 2.25 تا زمانی که یک نوع به نام `WinForms` نیز وجود نداشته باشد، به خوبی کار می‌کند. در آن صورت، کامپایلر `WinForms.Button` را به عنوان تلاشی برای استفاده از عضوی به نام `Button` در نوع `WinForms` به جای استفاده از `alias` فضای نام در نظر می‌گیرد. `C# 2` این مشکل را با معرفی یک قطعه سینتکس جدید به نام `namespace alias qualifier` حل می‌کند، که فقط یک جفت دو نقطه (`::`) است. این فقط برای `alias`های فضای نام استفاده می‌شود، بنابراین هرگونه ابهامی را از بین می‌برد. با استفاده از تعیین کننده‌های `alias` فضای نام، متد `Main` در لیست 2.25 به شکل زیر در می‌آید:
</div>

<div align="left">

```csharp
static void Main()
{
    Console.WriteLine(typeof(WinForms::Button));
    Console.WriteLine(typeof(WebForms::Button));
}
```
</div>

<div align="right">
لیست 2.25 `Alias`های فضای نام در `C# 1`
</div>

<div align="right">
<div align="left">`Alias`های فضای نام را معرفی می‌کند.</div>
<div align="left">از `alias`ها برای تعیین صلاحیت یک نام استفاده می‌کند.</div>
</div>

<div align="right">
ویژگی‌های جزئی 71
حل ابهام برای بیش از کمک به کامپایلر مفید است. مهمتر اینکه، به هر کسی که کد شما را می‌خواند کمک می‌کند تا بفهمد که شناسه قبل از `::` انتظار می‌رود یک `alias` فضای نام باشد، نه یک نام نوع. پیشنهاد می‌کنم هر جا که از `alias` فضای نام استفاده می‌کنید، از `::` استفاده کنید.
</div>

<div align="right">

<div align="right">`alias` فضای نام جهانی (`THE GLOBAL NAMESPACE ALIAS`)</div>
</div>

<div align="right">

اگرچه اعلام انواع در فضای نام سراسری (`global namespace`) در کد تولیدی (`production code`) غیرمعمول است، اما می‌تواند اتفاق بیفتد. قبل از `C# 2`، راهی برای تعیین صلاحیت کامل یک مرجع به یک نوع در فضای نام وجود نداشت. `C# 2` `global` را به عنوان یک `alias` فضای نام معرفی می‌کند که همیشه به فضای نام سراسری اشاره دارد. علاوه بر اشاره به انواع در فضای نام سراسری، `alias` فضای نام سراسری می‌تواند به عنوان نوعی "ریشه" برای نام‌های کاملاً صلاحیت یافته (`fully qualified names`) استفاده شود، و این همان روشی است که من بیشتر از آن استفاده کرده‌ام.
</div>



<div align="right">
به عنوان مثال، اخیراً با کدی سر و کار داشتم که متدهای زیادی از پارامترهای `DateTime` استفاده می‌کردند. هنگامی که نوع دیگری به نام `DateTime` به همان فضای نام معرفی شد، این امر برای اعلان‌های این متدها مشکل ایجاد کرد. اگرچه می‌توانستم یک `alias` فضای نام برای فضای نام `System` معرفی کنم، اما ساده‌تر بود که هر نوع پارامتر متد را با `global::System.DateTime` جایگزین کنم. من معتقدم که `alias`های فضای نام به طور کلی، و به ویژه `alias` فضای نام سراسری، به ویژه هنگام نوشتن تولیدکننده‌های کد یا کار با کد تولید شده که احتمال وقوع برخورد بیشتر است، مفید هستند.
</div>

<div align="right">

<div align="right">`alias`های خارجی (`EXTERN ALIASES`)</div>
</div>

<div align="right">
تا کنون در مورد برخوردهای نامگذاری (`naming collisions`) بین چندین نوع با نام یکسان اما در فضاهای نام مختلف صحبت کرده‌ام. در مورد یک برخورد نگران‌کننده‌تر چطور: دو نوع با نام یکسان در همان فضای نام اما ارائه شده توسط `assembly`های مختلف؟
</div>

<div align="right">
این قطعاً یک مورد خاص است، اما می‌تواند رخ دهد، و `C# 2` `alias`های خارجی (`extern aliases`) را برای رسیدگی به آن معرفی کرد. `alias`های خارجی در کد منبع بدون هیچ گونه ارتباط مشخصی اعلام می‌شوند، مانند این:
</div>

<div align="left">

```csharp
extern alias FirstAlias;
extern alias SecondAlias;
```
</div>

<div align="right">
در همان کد منبع، می‌توانید از `alias` در دستورات `using` یا نوشتن نام‌های نوع کاملاً صلاحیت یافته استفاده کنید. به عنوان مثال، اگر از `Json.NET` استفاده می‌کردید اما یک `assembly` اضافی داشتید که `Newtonsoft.Json.Linq.JObject` را اعلام می‌کرد، می‌توانستید کدی مانند این بنویسید:
</div>

<div align="left">

```csharp
extern alias JsonNet;
extern alias JsonNetAlternative;
```
</div>

<div align="right">
72 فصل 2 `C# 2`
</div>


<div align="left">

```csharp
using JsonNet::Newtonsoft.Json.Linq;
using AltJObject = JsonNetAlternative::Newtonsoft.Json.Linq.JObject;
...
JObject obj = new JObject();
AltJObject alt = new AltJObject();
```
</div>

<div align="right">
این یک مشکل را باقی می‌گذارد: ارتباط هر `alias` خارجی با یک `assembly`. مکانیسم انجام این کار خاص به پیاده‌سازی بستگی دارد. به عنوان مثال، می‌توان آن را در گزینه‌های پروژه یا در خط فرمان کامپایلر مشخص کرد.
</div>

<div align="right">
به یاد نمی‌آورم که هرگز مجبور شده باشم خودم از `alias`های خارجی استفاده کنم، و معمولاً انتظار دارم که آنها به عنوان یک راه‌حل موقت (`stopgap solution`) استفاده شوند تا زمانی که رویکردهای جایگزین برای جلوگیری از برخورد نامگذاری از ابتدا پیدا شوند. اما خوشحالم که آنها وجود دارند تا امکان این راه‌حل‌های موقت را فراهم کنند.
</div>
